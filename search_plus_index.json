{"./":{"url":"./","title":"简介","keywords":"","body":"docs 记录自己工作和学习当中一些经验笔记，包括技术工具、经验总结、兴趣爱好等相关笔记。 开源项目 less-wrapper-loader 一个给less文件添加统一命名空间用来规避样式冲突的webpack loader。 git-ref-tags 根据指定仓库地址快速获取项目tag信息。 WeChatAssistor 微信自动化助手。 更多 分享 蒙版弹幕原理分享 蒙版弹幕的原理分享。 联系方式 email: vary_007@163.com Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/":{"url":"technology/","title":"技术工具","keywords":"","body":"技术工具 记录工作学习当中的技术、工具、经验和技巧。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/":{"url":"technology/frontend/","title":"前端技术","keywords":"","body":"前端技术 前端相关技术的经验技巧总结。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/unkown.html":{"url":"technology/frontend/unkown.html","title":"前端知识点补漏","keywords":"","body":"前端知识补漏 JS Npm 浏览器缓存 Css Web Api webpack Others JS 变量赋值，数值型、引用型 参考 变量是存储在内存中的一块区域 重新赋值给一个变量会重新指向一个新区域 重新赋值给一个变量不会影响指向同一区域的其他变量 func内的餐宿和变量赋值同名时，如下demo1,可以想象成param1就是一个内部变量，var param1 = myString demo1 function myFunc(param1) { param1 = 'world'; // param1相当于只是个内部私有变量，给它的赋值不会影响外部变量的结果 console.log(param1); // Logs 'world' } var myString = 'hello'; // Calls myFunc and assigns param1 to myString just like param1 = myString myFunc(myString); console.log(myString); // logs 'hello' demo2 function myFunc(otherObj) { // Let's mutate our object otherObj.firstName = 'Sue'; // 不是reassign, 所以会改变存储区域里的值 console.log(otherObj.firstName); // Logs 'Sue' // Now let's re-assign otherObj = { firstName: 'Jack', lastName: 'Frost' }; // 是reassign, 所以otherObj得值变了，但不会影响其他指向原区域的变量 console.log(otherObj.firstName); // Logs 'Jack' // Again, otherObj and myObject are assigned to 2 very different objects // And mutating one object doesn't magically mutate the other } var myObject = { firstName: 'Joe', lastName: 'Smith' }; // Calls myFunc and assigns otherObj to myObject just like otherObj = myObject myFunc(myObject); console.log(myObject.firstName); // Logs 'Sue', 因为在内部已经改变了存储区域的值，所以是Sue es6 解构赋值（destructure）设置默认值 在使用 const { a } = obj时一般没有什么问题， 但是如果我们想得到a下的b,const { a :{b}} = obj,这样写时，在a不存在或者undefined的时候就会报错，block住程序的执行，可以给a设置默认值来避免报错，如下： const { a: { b } = {b:'this is test'}} = obj 或者 const { a: { b } = {}} = obj export/export default // export.js export const func1=()=>{xxx} export { // 和直接export 一样，可以通过{...}导入 func2 :()=>{xxx} } const m = 100; export default { m } //import.js import { func1 } from './export.js'; import { func2 } from './export.js'; import { m } from './export.js'; // undefined,这种导入方式会找不到,本质上default是把相关的变量挂在了名为default的属性上，所以以下两种方式可导入： import {default as x } from './export.js'; import x from './export.js'; x.m //ok 事件循环机制、调用栈、调用队列 调用栈、调用队列（可视图）参考 参考2 macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task包括：process.nextTick（就是then,或者catch）, Promises, Object.observe, MutationObserver 执行顺序：函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一种任务队列（可能有settimeout队列，settimmediate队列，指的是执行完其中的一种全部队列，不是一种队列中的一个），执行完之后再执行所有的micro-task，就这样一直循环 new Promise()内的代码是立即执行, nextTick 和 promise then的是单独的队列，且nextTick比then队列先执行 当调用栈中的代码都执行完毕后再把任务队列中的压入调用栈，然后执行。参考 console.log(1); setTimeout(function(){console.log(2);}, 0); console.log(3); //输出1，3, 2 settimeout（xx,0)，就是要把该函数块放入队列，等待其他的调用栈中的都执行完毕，再去把任务队列中的压入调用栈，然后再执行调用栈中的代码 经典例子 // demo02 console.log('golb1'); setTimeout(function() { console.log('timeout1'); process.nextTick(function() { console.log('timeout1_nextTick'); }) new Promise(function(resolve) { console.log('timeout1_promise'); resolve(); }).then(function() { console.log('timeout1_then') }) }) setImmediate(function() { console.log('immediate1'); process.nextTick(function() { console.log('immediate1_nextTick'); }) new Promise(function(resolve) { console.log('immediate1_promise'); resolve(); }).then(function() { console.log('immediate1_then') }) }) process.nextTick(function() { console.log('glob1_nextTick'); }) new Promise(function(resolve) { console.log('glob1_promise'); resolve(); }).then(function() { console.log('glob1_then') }) setTimeout(function() { console.log('timeout2'); process.nextTick(function() { console.log('timeout2_nextTick'); }) new Promise(function(resolve) { console.log('timeout2_promise'); resolve(); }).then(function() { console.log('timeout2_then') }) }) process.nextTick(function() { console.log('glob2_nextTick'); }) new Promise(function(resolve) { console.log('glob2_promise'); resolve(); }).then(function() { console.log('glob2_then') }) setImmediate(function() { console.log('immediate2'); process.nextTick(function() { console.log('immediate2_nextTick'); }) new Promise(function(resolve) { console.log('immediate2_promise'); resolve(); }).then(function() { console.log('immediate2_then') }) }) //执行第一轮宏任务队列（macro） golb1 glob1_promise glob2_promise //执行第一轮微任务队列（micro） glob1_nextTick glob2_nextTick glob1_then glob2_then 第一轮事件循环结束 //执行第二轮宏任务中的setTimeout队列（macro） timeout1 timeout1_promise timeout2 timeout2_promise //执行第二轮宏任务setTimeout产生的微任务队列（micro） timeout1_nextTick timeout2_nextTick timeout1_then timeout2_then 第二轮事件循环结束 //执行第二轮宏任务中setImmediate队列（macro） immediate1 immediate1_promise immediate2 immediate2_promise //执行第二轮宏任务setImmediate产生的微任务队列（micro） immediate1_nextTick immediate2_nextTick immediate1_then immediate2_then SSE(server-sent event) Html5引入的服务端发送消息机制，比socket 更加轻量，只能单向发送 路径动画() css 中使用motion-path. svg里的path. smil. npm 包管理逻辑 1.遍历循环所有包，包括包中依赖的包 2.扁平化dedupe即 deduplicated，去重 a.遇到**新包**放到最外层项目树下 b.遇到已有的包，判断两个版本是否在同一范围（相同，或者在可兼容的范围内） 是：则选择最新的可接受的版本放在外层树下 否：各自在自己树下生成，版本不同 一般使用如下,(package.json)： scripts:{ \"postinstall\":\"npm dedupe\" // postinstall 是npm的一个hook会在npm install 之后自动执行，还有一些其他的hook 如prebuild，pretest...... } 统一设置项目依赖的默认前缀 npm config set save-prefix=\"~\" 运行此命令，npm会拿你的package.json和node_modules目录进行比对，然后把那些在package.json中没有引用到的package列出来。还有那些你没有手动添加到package.json或者是执行npm install $package时没有加--save参数的，都会被删掉。 npm prune 使用shrinkwrap命令会在你当前项目中生成一个npm-shrinkwrap.json文件。它会将你当前package.json中引用的依赖版本锁定，当下次执行npm install时，它默认安装的其实是shrinkwrap.json中锁定的依赖版本号。 npm shrinkwrap 3.按照生成的依赖树安装 所以有时候外层项目并没有引用依赖一些包，但可以直接使用，就是因为内部依赖 的包的包被提取到了最外层的node_modules里 dependency/devDependency project-min install的时候安装，项目本身的dependency/devDependency包都会被安装，依赖的依赖下的dependency 包也会被安装，但devDependency不会安装。 ├── project-main ├── package-a (dependency) │ └── package-a-1 (devDependency) | └── package-a-2 (dependency) └── package-b (devDependency) 如图package-a 和package-b , package-a-2都会被安装，但package-a-1不会安装 dependency/devDependency 和webpack打包 我们开发的应用大概分为两种: 一种是正常的ui app 一种是供他人使用的libary(纯js,或者组件库) 正常的app install自己的包，然后使用webpack打包到dist目录，这时候一般会把dist目录host起来在浏览器访问，dist就是我们最终build的目录，直接使用即可，无需再install包 libary 场景1: 直接使用babel 转义后copy到dist 目录，比如各种组件库就是这样干的，这样就得到了一个es5的未打包的组件库，然后修改package.json中的main 属性，入口指向dist. 他人使用的时候因为要先install 这个libary, 同时会自动install它的dependencies, 直接import .. from ''即可。 libary 场景2: 使用webpack打包，类似于app, 然后修改package.json中的main 属性， 入口指向dist.他人使用的时候直接import .. from ''即可， 相比场景1，内部依赖已被打包进去，使用不用安装，可以配合webpack external优化要打的包，避免过大的bundle. peerDependencies peerDependencies的目的是提示宿主环境去安装满足插件peerDependencies所指定依赖的包，然后在插件import或者require所依赖的包的时候，永远都是引用宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。 Project A package.json { peerDependencies: { libA:'1.2' } } Project B package.json { dependencies: { ProjectA:'xxx' } } // B install 时如果没有libA1.2会有警告 UNMET PEER DEPENDENCY libA1.2 必须安装该包，否则会有异常 package.json 中的main 和module { \"main\": \"dist/dist.js\", \"module\": \"dist/dist.es.js\" } 相当于在一个包内同时发布了两种模块规范的版本。 当打包工具遇到我们的模块时： 如果它已经支持 pkg.module 字段则会优先使用 ES6 模块规范的版本，这样可以启用 Tree Shaking 机制。 如果它还不识别 pkg.module 字段则会使用我们已经编译成 CommonJS 规范的版本，也不会阻碍打包流程。 包版本管理方案 使用npm version patch|minor......等来直接更改package.json中的version版本号 CSS pointer-events: none; 类似a标签不响应事件 x:nth-child(n)/x:nth-of-type(n)， n可以是表达式或关键字‘odd‘/'even'（单复数） 前者是选择父元素下第n个子元素，且这个元素类型是x. 后者是选择父元素下的所有x类型的元素中的第n个.（其实自己以前用的nth-child大部分是错的，当成nth-0f-type在用了。 vw、vh、vmin、vmax vw、vh、vmin、vmax 是一种视窗单位，也是相对单位。它相对的不是父节点或者页面的根节点。而是由视窗（Viewport）大小来决定的，单位 1，代表类似于 1%。 counter, 用来生成列表的序号，属性如下： counter-reset 初始化一个counter counter-increment 序号如何增长（注意没有 decrement, 可以用负号表示） counter(name,style) 获取对应名为name的 counter 的当前序号，style是序号样式，默认 decimal,还有罗马字符什么的 counters(counter, string, style),获取名为name的对应的子序号 // html List item List item List item List item List item List item // css ul { counter-reset: counter; } li::before { counter-increment: counter; content: counters(counter, '.') ' '; } // 效果 1. 2. 3. 3.1 3.2 val, css自带变量功能 变量声明--variable-name: 使用 val(--variable-name:) .custom-variables { --some-color: #da7800; --some-keyword: italic; color: var(--some-color); font-style: var(--some-keyword); } vertical-align 强烈参考 浏览器缓存 因为last-modified 只能精确到秒，不如etag精确，所以在优先级上etag更优先 比较顺序cache-control->etag->last-modified Web Api window.URL.createObjectURL / revokeObjectURL 用于临时创建一个url给某个文件或二进制对象，一般用于下载，使用完后revokeObjectURL(...)释放文件的引用。 例子： const a = document.createElement('a'); a.style.display = 'none'; a.href = window.URL.createObjectURL(blob); a.download = 'filename';// download 指定下周的文件名 document.body.appendChild(a); a.click(); document.body.removeChild(a); window.URL.revokeObjectURL(a.href); escape、encodeURI、encodeURIComponent 区别 escape 是对字符串编码，其他两个是对URL编码。其中 ASCII字母、数字、@*/+ ，这几个字符不会被编码，其余的都会。 encodeURI,不会对下列字符编码 ASCII字母、数字、~!@#$&*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、~!*()' 使用场景 字符串编码使用\bescape URL编码使用\bencodeURI,如encodeURI('http://')=>http://,但如果使用encodeURIComponent('http://')=>http%3A%2F%2F URL中的参数用encodeURIComponent,这样如果参数中有'http://'这样的字符时就会被编码 Fullscreen var elem = document.getElementById(\"ele\"); elem.requestFullscreen() Document.exitFullscreen() Notification if (window.Notification){ if(Notification.Permission==='granted'){ var notification = new Notification('Hello Notification',{body:\"I hope that all the browser will support this\\ function!\"}); }else { document.getElementById('requestButton').onclick = function (){ Notification.requestPermission(); }; }; } offset/scroll 属性 offsetHeight, 每个元素的高度，包括border, 但不包括margin clienHeight, 每个元素的高度，不包括border,margin offsetTop， 每个元素距离其最近父元素的距离 scrollHeight，代表当前滚动区域内元素整个的高度，包括不可见的高度 scrollTop, 当A元素内的B元素的高度 > A 元素的高度，会出现滚动条，B元素向下滚动的距离(即被遮住的高度)就是scrollTop webpack commonChunk/external/entry(vendor)/dll entry: { index: './src/index.js', another: './src/another-module.js' }, plugins: [ new HTMLWebpackPlugin({ title: 'Code Splitting' }) }), new webpack.optimize.CommonsChunkPlugin({ name: 'common' // 指定公共 bundle 的名称。 }) ], externals: { jquery: 'jQuery' //key 是jquery 表示应该排除 import $ from 'jquery' 中的 jquery 模块。为了替换这个模块，jQuery 的值将被用来检索一个全局的 jQuery 变量，因为静态引入jquery后是生成了一个全局变量jQuery,所以value是jQuery. } commonChunk(webpack4 已经废弃，建议使用SplitChunksPlugin) 用来提取entry里所有入口的公用模块(一般是非第三方库），生成一个名为common的bundle文件，最后被添加到html文件 externals 外部扩展是用来把第三方库libary和自有代码分离，这样webpack打包时会忽略该第三方包, 在运行时去使用它的宿主环境去找被忽略的那个包，外部 library 可能是以下任何一种形式： root：可以通过一个全局变量访问 library（例如，通过 script 标签，即cdn这只是一种方式而已）。 commonjs：可以将 library 作为一个 CommonJS 模块访问。 commonjs2：和上面的类似，但导出的是 module.exports.default. amd：类似于 commonjs，但使用 AMD 模块系统。 externals : { lodash : { commonjs: \"lodash\",//如果我们的库运行在Node.js环境中，import _ from 'lodash'等价于const _ = require('lodash') commonjs2: \"lodash\",//同上 amd: \"lodash\",//如果我们的库使用require.js等加载,等价于 define([\"lodash\"], factory); root: \"_\"//如果我们的库在浏览器中使用，需要提供一个全局的变量‘_’，等价于 var _ = (window._) or (_);所以一般是导入script , 就会给window上绑定一个\"_\"变量，这样loadsh就能找到了。 这个\"_\"是不能随便乱写的。如果外部库lodash提供的是全局变量lodash,那你就得使用lodash } } 此语法用于描述外部 library 所有可用的访问方式。这里 lodash 这个外部 library 可以在 AMD 和 CommonJS 模块系统中通过 lodash 访问，但在全局变量形式下用 _ 访问。subtract 可以通过全局 math 对象下的属性 subtract 访问（例如 window['math']['subtract']）。 对于external的依赖模块，通常你可以这样做，例如你使用npm发布你的库，你可以将jquery在package.json文件中添加到dependencies，这样别人npm install你发布的库时，jquery也会被自动下载到node_modules供别人打包使用。 所以总结如下： 针对正常app, react这些比较大的第三方库我们应该使用dll，然后去引用 针对 library, 应该使用external让宿主去install然后在宿主环境中去寻找，宿主环境该打包打包 entry(vendor)针对第三方库,如下 entry: { index: './app/main.jsx', vendorx: ['react', 'react-dom', 'react-router', 'classnames'] }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ names: ['vendorx', 'manifest'],//注意这里的names 可以配置entry里的name,比如现在有个vendorx, 它就只会提取vendorx入口里文件的公共模块，如果不配置name,默认提取所有入口的公共模块 }), ] 这种方式会把所有的第三方库打包到名为vendor的bundle中，然后添加进html文件。 指定manifest会修复每次打包vendor的hash值会变的问题。 dll针对\b第三方库\b参考 在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 react，lodash，我们希望能和自己的代码分离开，Webpack 社区有两种方案 a.CommonsChunkPlugin b.DLLPlugin 对于 CommonsChunkPlugin，webpack 每次打包实际还是 需要去处理这些第三方库，只是打包完之后，能把第三方库和 我们自己的代码分开。而 DLLPlugin 则是能把第三方代码完全分离开，即每次只打包 项目自身的代码。 webpack-dev-server 开启热加载，自带监听,打开网页等功能，需要注意的是有了webpack-dev-server之后，启动命令就可以不用webpack --watch了，直接webpack-dev-server即可,webpack-dev-server build的文件在dist中看不见，webpack build的可以看见。 contentBase 是server 静态文件， publicPath 是server 打包的文件 src |__base |__a.js |__b.png |__index.html |__dist |_bundle.js |_index.html { webpack-dev-server: { contentBase:['base','xxx']//可以server多个目录 publicPath:'dist'// 不配置默认就是dist文件夹，只不过在内存中看不到 }， output:{ path:'dist'// dev-server模式下，其实没用，还是优先使用wds的publicPath输出目录 } 项目结构如图 1. contentBase内所有文件被server了,一般存储静态文件，所有都能访问到。 2. base内部的index.html只是作为模板输出到dist中的index.html. 所以可以利用contentBase的特性server静态文件，同时dist文件夹内的也被server，相当于能同时访问两个地方的文件。 htmlWebpackPlugin 如果不配置该插件，要手动把index.htmln挪动到dist文件夹，不然localhost:port不显示任何内容，使用该插件后，会自动依据模板生成index.html文件到dist目录，这时候localhost:port就有内容了。 workbox-webpack-plugin progressive web application - PWA, 离线依然可使用， 注意需要vpn（访问谷歌） publicPath/contentBase webpack-dev-server.publicPath: 开发环境中，所有打包文件的输出目录，只在开发环境中起效 webpack-dev-server.contenBase: 静态文件的文件html所在的目录，一般和output.path一样 output.publicPath: 设置打包输出的文件内静态资源的引用 前缀 // build:'webpack', // dev:'webpack-dev-server' output: { path: 'dist', publicPath:'/output/' }, webpack-dev-server: { contenBase:'dist'， publicPath:'/dev/' } 首先明确以下概念： webpack-dev-server的配置只在开发环境有效 webpack-dev-server的publicPath如果不配置，默认和output的publicPath值一样 两者都存在时，开发模式下，由于webpack-dev-server编译后的的文件都在内存中，看不见(可以在浏览器访问对应的localhost:xxx/webpack-dev-server看到目录结构)，wds实际是默认把输出的编译文件放在了项目的根目录（即开发环境下output的path无效，它只是设置再生产环境实际打包的文件路径），而如果配置了wds的publicPath，就会把输出的文件从根目录转移到publicPath下。 比如现在的配置，在wds下实际的打包文件地址在dev目录下，而dev目录里的index.html或其他的js内的静态资源引用的路径前缀都是/output/比如/output/test.png，而这种情况下如果访问首页会发现静态资源请求不到，因为现在所有的文件被server在了/dev目录下，如下： pro |--dev |-test.png |-index.html |-package.json // index.html 这样肯定找不到图片，除非`wds`的`publicPath`设置成`/output/`，或者`output`的`publicPath`设置成`dev`,这也是官方建议：开发环境下，没必要设置`wds`的`publicPath`或者和`output`的`publicPath`的设置一样的值。 两者都存在时，生产模式下，wds的设置将不再生效，我们只需看output的设置。 此时，会生成真实的打包文件到/dist/下，同时内部的静态资源引用会都加上/output/前缀（一般用来加cdn），所以在生产环境下，必须得把打包出来的静态资源放对地方，必须现在的就必须放在/output/下，不然还是找不到，一般静态资源会被放在cdn上，所以确保cdn服务器上的路径设置正确。 静态资源的引用 在实际生产中有以下几种图片的引用方式： .photo { background: url(photo.jpg);} var imgTempl = ''; document.body.innerHTML = imgTempl; `import React from 'react'; import ReactDOM from 'react-dom'; class App extends React.Component { render() { return (); } }` 1,3,4的引用方式使用webpack打包后会发现图片并没有打进去，实际上webpack只会自动提取样式文件中的引入，其他引用图片的地址应该如下： import photo from 'photo.jpg' 要把静态资源也当成模块导入，这样就能正常打包了 Jest + webpack 使用jest的时候，因为组件中可以直接使用import from 'style.less'导入静态文件（webpck功能），所以在jest下，需要模拟出这种功能，让静态资源的也已模块的形似导入，一般使用identity-obj-proxy这个库，可以参考jest文档webpack部分。 splitChunk 参考系列文章 module：就是js的模块化webpack支持commonJS、ES6等模块化规范，简单来说就是你通过import语句引入的代码。 chunk: chunk是webpack根据功能拆分出来的，包含三种情况： 　　　　1、你的项目入口（entry） 　　　　2、通过import()动态引入的代码 　　　　3、通过splitChunks拆分出来的代码 　　　　chunk包含着module，可能是一对多也可能是一对一。 bundle：bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，bundle就是对chunk进行编译压缩打包等处理之后的产出。 默认splitChunk配置如下，会split nodemodule里的包和最少引用两次以上的代码块 optimization: { splitChunks: { chunks: 'async', minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: {// cacheGroups里的配置可以覆写splitChunks的外层配置，很重要, 同时其内部的条件必须同时满足才能生效 vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } chunks的含义是拆分模块的范围，它有三个值async、initial和all。 async表示只从异步加载得模块（动态加载import()，不是import xx from xx）里面进行拆分 initial表示只从入口模块进行拆分 all表示以上两者都包括 假如只配置了'async',那么入口文件里的vendor的包或者代码块就不会被拆分，都会被打到一个chunk，即入口chunk里 maxInitialRequests 它表示允许入口（即initial对应的入口，同理maxAsyncRequests是限制dynamic import的）并行加载的最大请求数，之所以有这个配置也是为了对拆分数量进行限制，不至于拆分出太多模块导致请求数量过多而得不偿失 拆分规则如下： 入口文件本身算一个请求 如果入口里面有动态加载得模块这个不算在内 通过runtimeChunk拆分出的runtime不算在内 并不算js以外的公共资源请求比如css 如果同时又两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来 maxAsyncRequest import()文件本身算一个请求 并不算js以外的公共资源请求比如css 如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来 others eslint extends { \"extends\": \"an\", //会查找名为eslint-config-an的第三方包配置(要先安装) } env { env:{ jest: true, // 会开启jest相关的所有全局变量，相关的linter就不会报错了 node: true // 同理 } } import/resolve 当在webpack中配置了resolve：{module:['src']}时，代表webpack会从src下去解析module,但eslint不知道，所以相关的linter会报错，解决办法下载eslint-import-resolver-webpack插件并如在.eslintrc下配置settings 项： \"settings\": { \"import/resolver\": { \"webpack\": { \"config\": { resolve: { extensions: ['', '.js', '.jsx'], modules: ['src', 'node_modules'] } } } } } babel 转码过程parsing => transforming => generating babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决 { \"presets\": [\"react\", \"es2015\", \"stage-1\"], // preset 就是一些预置的插件集合 // stage-0/1/2/3, 涵盖范围逐渐减小 \"plugins\": [ \"transform-runtime\", \"add-module-exports\" ], // 先执行plugins 再执行preset, plugin正顺序执行，preset 倒叙执行 // plugins在transforming 阶段执行 \"env\": { // env 默认从process.env.BABEL_ENV || process.env.NODE_ENV获取 \"static\": { \"plugins\": [ \"react-hot-loader/babel\" ] }, \"test\": { \"plugins\": [ [\"istanbul\"] ] } } } Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/browser_cache.html":{"url":"technology/frontend/browser_cache.html","title":"浏览器缓存","keywords":"","body":"浏览器缓存 机制 chrome中resource 中的frame是当前的所有缓存文件 expires /cache-control 前者是http1.0的标准，后者是1.1的标准，当两者同时出现时，一后者的为准 etag/if-none-match,是一个hash值代表文件的唯一性，如果有此标签，请求会和response的etag去对比，如果不一样说明文件被更改，服务器会返回 200,否则３０４ last-modify/if-modify-since，是一个事件戳，通过对比最后修改时间，然后交给服务器区判断返回２００还是３０４ 流程如下 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/react.html":{"url":"technology/frontend/react.html","title":"react相关笔记","keywords":"","body":"React 经验技巧总结 不要在jsx的render中使用箭头函数 本质一句话： 如果oncliK的的事件委托是用的箭头函数，那么每次该函数执行时会生成一个新的函数，正常情况没事，但一旦作为父props传递给子组件时，子组件就会认为props发生变化，从而重新render 传参可以这样 Delete Row 参考1; 参考2 setState 合并 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。 constructor(props) { super(props); this.state = { posts: [], comments: [] }; } 然后你可以分别调用 setState() 来单独地更新它们： componentDidMount() { fetchPosts().then(response => { this.setState({ posts: response.posts }); }); fetchComments().then(response => { this.setState({ comments: response.comments }); }); } Render Props : 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术 ( // 并不一定要命名为render, 只要是传的render函数，任何命名都可以 Hello {data.target} )} /> 这样就可以封装一些公用的逻辑，在外部接受一个render函数延迟执行render, 本质和HOC差不多 Hook a. hook只能在最顶层使用， 不要在循环、条件、嵌套中使用（如有必要，将条件写在hooK里面） 因为react是按照hook的声明顺序来标示对应的hook的，如果写在条件判断或者循环中每次执行时的顺序可能会有差异，导致hook的值错乱 b. 只在react 函数中调用hook,即（React 函数组件和自定义的hook中调用） c. hook只在函数式组件中有效，class组件无效 useEffect a. 性能优化，第二个参数接收一个数组，可以只watch数组里的变量，只在更改时触发effect。如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量 b. 如果想执行一次effect（仅在组件挂载和卸载时执行）, 需要给第二个参数传个空数组[],因为传空数组本质是由于此时effect 内部的 props 和 state 就会一直持有其初始值不会变化。 userLayoutEffect 和useEffect相比，该hook是在重新渲染绘制之前执行，这样不会导致页面的闪动 useRef 本之上和React.createRef()差不多 // React.createRef() const FancyButton = React.forwardRef((props, ref) => ( {props.children} )); // 你可以直接获取 DOM button 的 ref： const ref = React.createRef(); Click me!; // useRef function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () => { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( <> Focus the input ); } useCallback/useMemo 用来在监听的某些属性改变之后调用，区别是useCallback, 返回的是个回调函数，而useMemo返回的是个值，参考使用方式。 const cb = useCallback(()=>`callback:${name}`,[name]); // 允许你在重新渲染之间保持对相同的回调引用以使得 shouldComponentUpdate 继续工作， 除非name改变 const memo = useMemo(()=>`memo:${name}`,[name]); return ( Name: {name} cb name: {cb()} memo name: {memo} setName(Math.random().toFixed(2)*1000)}>random name ); React.Memo React.Memo不同于useMemo, 前者使用来在组件层级通过浅比较props的previous 和 next值来觉得是否渲染从而优化组件性能，后者是在组件中通过判断内部props 或 state的值来优化内部的方法等性能。 浅比较默认只比较两次对象是否是同一引用，不会逐个遍历对象属性去判断，优点是性能好，缺点是可能比较的结果和我们预期的不同，看例子： var a = { name:'java'}; var b = { name:'java'}; shallowEqual(a,b) 为false, 因为a,b不是同一个对象引用，但其实内部的值是一样的 所以在使用React.Memo时应该注意，如果是想要优化组件性能，最好使用深比较，lodash.isEqual是深比较，但如果比较的对象层级较深，本身也比较耗性能。 需要注意props里如果有匿名的函数比如onClick回调，深比较将每次都返回false,因为匿名函数每次都是生成新的 所以默认的React.Memo适合那些比较的props比较简单且比较少的情况，要根据不同组件来取舍。 自定义hook a. 必须usexxx命名函数 b. 内部必须使用原生的hook c. 本质就是一个函数，可以返回一个值或者类似useState一样（xxx和setxxx方法, 可以参考useReducer） HOC HOC主要有两种模式， Proxy Props 和Inheritance Inversion Proxy Props a. 读取，编辑 WrappedComponent 的props， 没法获取state 和实例方法 b. 读取WrappedComponent 的ref引用 function ppHOC(WrappedComponent) { return class PP extends React.Component { constructor(pros) { super(props); } proc(wrappedComponentInstance) { wrappedComponentInstance.method() } render() { const props = Object.assign({}, this.props, {ref: this.proc.bind(this)}) return } } } Inheritance Inversion 反向继承 a. 读取WrappedComponent 的props,state和实例方法 b. 劫持渲染 c. 改写WrappedComponent的生命周期方法 function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { render() { return super.render() } } } React性能相关 参考 React性能优化 优化前先关闭chrome所有插件，或直接使用匿名模式，因为插件会影响性能结果 建议使用whyDidYouRender库，调试组件reRender状态；建议使用chrome=>performance 页签录制操作查看性能报告 列表添加key,优化虚拟dom 比较 key 必须唯一（列表内唯一），不建议使用遍历的index,当顺序改变时会导致bug产生 pureComponent/React.memo, 优化判断shouldComponentUpdate , 配合isEqual实现深对比，配合immer实现不可\b变对象 对于无状态组件即无props的组件，也要使用React.memo包装，如下 function Parent(){} function Child(){ xxx } // 每次parent reRender都会导致Child reRender, 因为child虽然没有props参数声明，但其实其值是一个`{}` ,当Parent reRender时，相当于给child又传递了一个{},虽然两次值一样，但由于{} !== {}, 所以还是会更新，所以需要使用React.memo封装下 useEffect 添加正确依赖，防止非必要触发 useEffect(()=>{ xxx },[a]) // 注意如果这里的a是个对象或者数组，会每次都触发，因为是引用比较，解决方案使用use-deep-effect 库进行深度比较或者使用usePrevious 对上一次的值进行比较 使用useMemo/useCallback缓存不是每次都要更新的值，只有在其依赖值变化是才触发 不要使用箭头函数作为事件回调，因为箭头函数每次都会生成新，当作为props传递的时候会触发reRender 不要使用行内对象，如 const style = {width: 200px} ; 每次生成的都是新的对象导致重新渲染 避免使用会引起浏览器回流（reflow）的css, 如隐藏元素可以使用opacity: 0 替代display: none React 父-子依赖问题 // 如下，如果parent负责触发通用的一些api并set到reducer, child中有相关的逻辑必须依赖parent中set的数据 // 正常渲染的顺序会是先渲染child 完了后再渲染parent, 这时候就没法拿到正确的依赖数据了， // 正确做法是在渲染child前加条件，其条件就是依赖数据是否已存在 // => {hasData && } Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/redux.html":{"url":"technology/frontend/redux.html","title":"redux相关笔记","keywords":"","body":"Redux redux 和react-redux 前者是action,store,reducer这些的概念下的东西，react-redux是ui绑定库，只有provider和connect 1.action和action创建函数的概念要清楚，创建函数就是返回一个action action文件中一般有一个type常量，还有一个对应的同名（不同名也行）的action创建方法 action.js /* * action 类型 */export const ADD_TODO = 'ADD_TODO'; * 其它的常量 * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }} reducer.js文件中是根据常量的值来计算state,并不调用action创建方法，创建方法是在 view组件中，互动调用的，一般为事件，不要搞混 2.不要在reducer里修改state,而是返回新的state,一般用object.assign({},state,xx) 3.redux和react进行绑定时用react-redux里的connect方法,这样只订阅需要的state 每个被provider包裹的组件都能接收store=>前提该组件必须是被connect方法连接了的组件， 关于connect方法可以参考这个和官方文档 其实就是注入state(或者选择对应的state),注入action,最后都合并成组件的props,方法有些怪异，多看看 组件的props就是property（属性）的缩写，父组件给它穿什么就有有什么，也可以在组件中定义，父组件如果不传就是undefined creatStore(reducer, [initialState], enhancer),第一个参数是一个reducer,但一般是传递的一个合并过的reduderApp,(reducer不是state,它只是定义了不同的state在不同的action下如果产生的而已)，相当于一张state树，当dispatch以后如下（只是传入了action,并没有具体的指明要哪个reducer调用，store怎么知道在哪个reducer上触发action呢？） 其实原因是默认store会在整个的state上判断action(actionType必须唯一)，然后触发，这样明显性能不好，所以在(react-redux)connect的时候mapStateToProps方法会返回你定义的想要获取的state,然后优先在这些的reducer里去判断action,如果符合则触发 建议看这个 state的树是由reducer组织起来的，和connect里的没什么关系 export default connect( state => ({ orderSummary: state.modules.Cart.Checkout.orderSummary, applyGiftCardx: state.modules.Cart.Checkout.applyGiftCard//这里的applygitfCardx,只是临时合并到这个组件的props中，总的state树名称还是不变 })} store.dispatch({type:'add_todo',text:'name'}),本来是要这样触发action,但写法不方便，有了actionAcreator,就可以store.dispatch(addTodo('name')); 4.用了redux后，所有的state都被store管理，原则上组件中就不再出现state,store计算出state,然后以prop的形式往下传 如果不用redux,原生的react 还是得配合state才行 5.官方建议的只在顶层connect是不对的，目前的最佳实践是将组件按照 “展现层（presentational）” 或者 “容器（container）” 分类，并在合理的地方抽象出一个连接的容器组件： 不要搞混了，store只能有一个，但connect的组件可以有多个，一般建议是在各个组件容器connect， UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑 connect 只是返回一个绑定了自定义state和reducer到props的心的组件而已 跨reducer共享state 中间件 //签名如下 function md(extraArgs) { return ({dispatch, state})=> next => action {xxx} } 多读这个 middleWare,签名为（store即{disptch, getState})=>next=>action的方法，thunk是一种实现 action , 签名为（）=> (dispatch, getState不是花括号)=> {xxx} 1. ==== // 比如现在有一个如下的异步action, dispatch和state是怎么传进来的呢？ 往下看 export const updateCouponCodeAction = code => (dispatch,state) => { dispatch(uiUpdateErrorAction({ errorMsg: null })); return dispatch(uiSelectCouponAction(code)); }; 2. ==== // 调用 class DcCoupon { this.props.updateCouponCodeAction(); } export default connect( null, { updateCouponCodeAction // 相当于返回key和value都为同名的且绑定过dispatch的方法 } )(DcCoupon); // 这里mapDispatchToProps 本身可以有两种方式，对象（如上）或方法， 如下 当为方法时，接收一个dispatch参数，返回一个绑定dispatch过得对象 function mapDispatchToProps(dispatch) { return { actions: bindActionCreators(actionCreators, dispatch) } } export default connect(mapStateToProps, mapDispatchToProps)(TodoApp) 3. ==== 无论是对象方式还是方法方式，当我们使用this.props.updateCouponCodeAction('test') 时，相当于这个 (dispatch,state) => { dispatch(uiUpdateErrorAction({ errorMsg: null })); return dispatch(uiSelectCouponAction(code)); }; 被dispatch触发了，此时就走到了middleware中，同时因为触发的是方法，一般都会用thunkmiddleware, 如下： export default function thunkMiddleware() { return ({ dispatch, getState }) => next => (action) => { if (typeof action === 'function') { return action(dispatch, getState);// 就是中间件这里传进去了disptch和getState, } return next(action); }; } 所以就能理解为什么中间件和异步action的签名会是这样了。 provider, 是为了解决不用把store层层往下传递的问题，实现本质是context. provider 接受store 之后， 子组件都能在connect 中接收到state,从而被动更新。但注意一般只在container层有选择的选择自己需要的state进行注入 注意本质上我们的目的是要重新包装dispatch，替换dispatch方法，next指代的是dispatch,只不过不是简单的指向系统的store.dispatch,而是下一个被包装过的dispatch，如图 applyMiddleware : 为了保证你只能应用 middleware 一次，它作用在 createStore() 上而不是 store 本身。因此它的签名不是 (store, middlewares) => store， 而是 (...middlewares) => (createStore) => createStore cui 使用符合签名 const middleware = __DEV__ || __STATIC__ ? composeEnhancers(applyMiddleware(...middlewareList)) : applyMiddleware(...middlewareList); const store = middleware(createStore)(rootReducer, initialState); 但是官方文档还有句话： 由于在使用之前需要先应用方法到 createStore() 之上有些麻烦，createStore() 也接受将希望被应用的函数作为“最后“一个可选参数传入, 所以还有可以当场createStore的第三个参数直接传进去（applyMiddleware只是该可选参数的一种而已，并不是唯一，看官方文档），比较方便，如下 import { createStore, combineReducers, applyMiddleware } from 'redux' let todoApp = combineReducers(reducers) let store = createStore( todoApp, // applyMiddleware() 告诉 createStore() 如何处理中间件 applyMiddleware(logger, crashReporter) ) applyMiddleware（...middlewares）,是用来串联各个middleware的方法，这样所有的middleware就可以以next()的机制来层层调用dispatch compose,是applyMiddleware中最核心的一个方法，使用它才实现了串联， compose的实现，其实就是一个柯里化得过程， function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args)) //就是一个函数执行完后又是另一个函数的参数 // 如[A,B,C],compose第一次是C，f是B，即B（C），第二次，compose是B（C），f是A，则结果A（B（C）） // } applyMiddleWare 实现 方法一： function applyMiddleware(store, middlewares) { middlewares = middlewares.slice() middlewares.reverse() let dispatch = store.dispatch middlewares.forEach(middleware => dispatch = middleware(store)(dispatch) // 循环执行每次改变dispatch的值 // 注意第一次执行的时候的那个middleware拥有最原始的dispatch， 即store.disptach, 后边的都是包装过得dispatch ) return Object.assign({}, store, { dispatch }) } 方法二：因为方法一是循环的实现，并不是串联，所以真正实现是方法二 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) => (...args) => a(b(...args))) } //可以看出compose做的事情就是上一个函数的返回结果作为下一个函数的参数传入。 export default function applyMiddleware(...middlewares) { return (createStore) => (...args) => { // 之后就在这里先建立一个store const store = createStore(...args) let dispatch = store.dispatch let chain = [] // 将getState 跟dispatch函数暴露出去 const middlewareAPI = { getState: store.getState, dispatch: (...args) => dispatch(...args) } chain = middlewares.map(middleware => middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) // 这里和方法一循环实现不同，实现了串联，然后最右边的middleware接受原始的store.dispatch // 所以执行时候右边先执行，然后层层返回 return { ...store, dispatch } } } thunk,是一种中间件，只是让action可以传递方法，但它没有提供异步方法，一般还得使用ajax或者fetch来实现，像redux-promise就提供了自己的实现 reducer //签名如下 function (state, action) {xxx} state 设计：想象成数据库，每个对象想象成单独的表，利用这种扁平的结构，使用引用，而不要使用嵌套的，如下 //不要这样 state:[ {post1:{ author:{name:'',age:''}, comments:[{ content:'xxxx', date:2016/09/12 }, { content:'xxxx2', date:2016/09/12 } ] }, {post2:{ author:{name:'',age:''}, comments:[{ content:'xxxx', date:2016/09/12 }, { content:'xxxx2', date:2016/09/12 } ] } } ] //要使用以下方式,范式设计，扁平结构，修改一处，多处引用 state:[ post:{ byid:[ post1:{ author:'user1', comments:['comment1','comment2'] }, post2:{ author:'user2', comments:['comment1','comment2'] } ] }, authors:{ byid:[ user1:{}, user2:{} ] }, comments:{ byid:[ comment1:{} comment2:{}, ] } ] state的初始值 immutable文档参考 有两种方法设置初始值，一种是在creatStore的第二个预设参数上设置，另一种是在具体的reducer中使用state= initState，来设置强烈参考 要注意的是优先级的问题，creatStore参数>reducer中initState，如果creatStore没设置，以reducer为准 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/grid_layout.html":{"url":"technology/frontend/grid_layout.html","title":"grid布局","keywords":"","body":"Grid Layout 参考这个 参考2 CSS Grid VS Flexbox：实例对比 类似flex wrapper div: display: grid; grid-template-columns: 100px 10px 100px 10px 100px 10px 100px; //设置列宽度，有几个值就有几列，auto时自动填充剩余的宽度， 用fr单位可以将容器分为几等份，例如下面分成三等份 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: auto 10px auto 10px auto; child div: grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2 简写一： grid-column:1 / 2; grid-row:1 / 2; 简写二： grid-area: 1 / 1 / 2 / 2;//row start,column start,row end,column end 定义在网格容器上的属性 display grid-template-columns grid-template-rows grid-template-areas grid-column-gap grid-row-gap grid-gap justify-items //横轴排列 align-items //竖轴排列 justify-content align-content grid-auto-columns grid-auto-rows grid-auto-flow //排列方向 grid-column-gap/grid-row-gap 网格列间距 grid-row-gap: 15px; 简写 grid-gap:15px 15px; justify-items/align-items/justify-content/align-content 主轴/辅轴/网格区域 对齐 justify-content/align-content 当网格区域小于网格容器时生效 grid-auto-flow : row（默认） | column | dense ; 在没有设置网格项的位置时，这个属性控制网格项怎样排列。 row: 按照行依次从左到右排列。 column: 按照列依次从上倒下排列。 dense: 按先后顺序排列。 定义在网格上的属性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area 定义网格项名字，\b可以是名字或者网格线区域 grid-area:header; 或者 grid-area:1 / 1 / 2 / 2; justify-self align-self grid vs flex CSS grids 适用于布局大画面。它们使页面的布局变得非常容易，甚至可以处理一些不规则和非对称的设计。 Flexbox 非常适合对齐元素内的内容。你可以使Flex 来定位设计上一些较小的细节。 2D 布局适合使用 CSS grids（行与列）。 Flexbox 适用于单一维度的布局（行或列）。 尤其在grid 布局大的页面时，配合grid-template-areas\b可以非常方便的调整区域，如下 ```css //\b只需要每次调整\bareas中的各个区域名称的分布即可， 配合响应式布局非常灵活 grid-template-areas: \"header header\" \"main sidebar\" \"footer footer\"; .header { grid-area: header; } .main { grid-area: main; } .sidebar { grid-area: sidebar; } .footer { grid-area: footer; } ``` Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/node.html":{"url":"technology/frontend/node.html","title":"node相关笔记","keywords":"","body":"Node exports/module.exports 参考 模块导出的最终是module.exports,exports只是前者的一个引用 如果想把文件导出成一个特殊的类型，比如类，数组等，使用moudle.exports, 如果只是\b想导出实例请使用exports导出一个实例 Buffer 在node中是一个全局变量 global filename/dirname 是指当前脚本的模块路径/目录路径，process.cwd()是指node进程的工作目录，不一样 process process.argv :返回执行当前脚本的命令参数数组，如node main.js ip，返回[ '/usr/local/bin/node', '/Users/garywang/work/learn/python/node/global.js', 'ip' ] process.env :返回shell的环境变量，一般用来\b判断开发环境，和argv不同 process.execPath : 返回node二进制程序的执行路径 child_process 子进程，一般用来开启新的shell,执行命令等。参考 每个子进程带有三个流，child.stdin, child.stdout 和child.stderr， 1 exec(command[, options], callback),有callback,会把子进程命令的结果以stdout的形式返回，如callback(err,stdout,stderr),注意option对象可以设置一些环境变量之类的配置 适合返回数据量不大的命令 2 spawn(command[, args][, options),没有callback 如spawn('node',['index.js','-ip']),就是把所有的参数都和命令分开了。 const ls = spawn('ls',['-a'], { stdio: 'inherit'// 可以是'ignore'/'pipe'/'inherit'([0,1,2]) ,默认‘pipe’ }); ls.on('data', (data) => { console.log(`stdout: ${data}`); });// 当时inherit时，对应的stdio 流传给父进程，就是ls.on, 而不是 *ls.stdout.on*, 如果是‘pipe’，就是ls.stdout.on(xx)来接收流了 ls.on('data', (data) => { console.log(`stderr: ${data}`); }); ls.on('close', (code) => { console.log(`子进程退出码：${code}`); }); 3 fork(modulePath[, args][, options])是spawn的特殊类型，注意参数格式，直接是模块名称不是命令,会创建一个V8实例，出来除了拥有所有的spawn实例方法以外还有一个和父进程通信的信道,通过监听'on','message'方法来通信，只有fork能通信 parent.js console.log('parent pid: ' + process.pid); var fork = require('child_process').fork; //fork方法返回的是子进程 var child = fork('./child.js'); console.log('fork return pid: ' + child.pid); child.on('message', function(msg){ console.log('parent get message: ' + JSON.stringify(msg)); }); child.send({key: 'parent value'}); child.js console.log('child pid: ' + process.pid); process.on('message', function(msg){ console.log('child get message: ' + JSON.stringify(msg)); }); process.send({key: 'child value'}); readline 每次读取用户输入的一行，常用来做交互、单行读取文件 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout, prompt: '请输入> ' }); rl.prompt(); rl.on('line', (line) => { switch (line.trim()) { case 'hello': console.log('world!'); break; default: console.log(`你输入的是：'${line.trim()}'`); break; } rl.prompt(); }).on('close', () => { console.log('再见!'); process.exit(0); }); Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/test.html":{"url":"technology/frontend/test.html","title":"测试相关笔记","keywords":"","body":"测试相关总结 enzyme - shallow(shallow) 只在虚拟dom中渲染第一层（不是第一层节点，而是第一个组件）,不渲染子组件（未使用嵌套组件的情况下），大部分情况下应该使用这种 shallow中有个API (dive()),只能用在非dom的元素上，比如包装了多层最后default导出的component,就可以直接使用default的然后在其上使用dive()方法，如果包裹多层就使用多次。 full (mount)加载到真实dom,当需要测试liftcycle,或者使用了自定的嵌套组件， 和有DOM交互的地方使用 static(render) 渲染成html字符，和shallow区别在于使用了第三方库，一般不常用，和shallow功能一样 shallow/mount区别 class CommentList extends Component { render() { return ( Comment One ) } } class Root extends Component { render() { return ( Welcome to testing React! Welcome to testing React! ) } } //// const mountWrapper = mount(); const shallowWrapper = shallow(); mountWrapper 会把所有的渲染， shallowWrapper 只会在内存中渲染Root组件，不会渲染其中的CommonList组件，如果调试输出: shallowWrapper.text() = \"Welcome to testing React!Welcome to testing React!\"//没有渲染CommnetList shallowWrapper.html() = \"Welcome to testing React! Comment One Welcome to testing React!\" //这里注意html（）虽然是最终渲染的结果，但并不是说shallow会进行最终渲染，只是html（）这个方法会最终渲染所有的，一定注意区别 mountWrapper.text() = \"Welcome to testing React! Comment One Welcome to testing React!\" // 渲染了CommentList mountWrapper.html() = \"Welcome to testing React! Comment One Welcome to testing React!\" simulate（‘xx’，{target:{value:text}}）,事件统一没有on前缀，直接是事件名，第二个事件参数是一个模拟对象会和event对象合并到一起传入到事件当中,如： {testFunc(e.target.value)}}/> input.simulate('click',{target:{value:123}}); //用到了哪个属性就模拟哪个属性 重要 模拟非标准dom事件，即自定义事件时，不用找到内部的标准事件去模拟，直接使用wrapper.find(xx).prop('customEvent')(fakeEvent)//注意不是props,后者是props.customEvent 看这个 demo { this.props.hideWarningAlertAction(); }} it.only('should trigger modal close correctly', () => { const { component, checkScrollModal, actions } = setup(); { return actions.hideWarningAlertAction;//函数体内任意代码，只要有模拟的方法就行，默认的那个action就会被执行，很奇怪 });--> checkScrollModal.prop('onScrollToBottom')();//什么都不写也可以执行 expect(actions.hideWarningAlertAction).toHaveBeenCalled();//这样就可以了 }); //jest 测试写法 const _ins = component.instance(); const spy = jest.spyOn(_ins, 'handleClick'); xxx.prop('ShowDeleteTransactionAlert')(2); expect(spy).toHaveBeenCalledWith(2); 测试组件内部方法或属性，使用component.instance() class A extends React.component{ handleClick(){ xxxx } componentDidMount(){ xxx } } // 内部方法测试 const { component } = setup(); const _ins = component.instance(); const spy = expect.spyOn(_ins,'handleClick');//这样就能spy上 //_ins.handleClick()就可以访问到 ... // 生命周期测试 // 需要注意的是一定要在组件中声明的方法或者生命周期方法才可以测试 const spy = expect.spyOn(_ins,'componentDidMount');//这样就能spy上 React tesing library(RTL) RTL从用户使用角度帮助测试UI组件的一组包 几点原则需要注意： RTL vs Enzyme 参考 不关注实现细节，只关注用户交互 避免以下实现细节 组件内部状态 组件内部方法 组件生命周期 子组件 get/query/find import {screen, getByLabelText} from '@testing-library/dom' // With screen: const inputNode1 = screen.getByLabelText('Username') // Without screen, you need to provide a container: const container = document.querySelector('#app') const inputNode2 = getByLabelText(container, 'Username') 当get/query/find 选择不到目标节点的时候 推荐使用data-testId 属性 -priority getByRole getByLabelText getByPlaceholderText getByText // 应用于非输入性组件 getByDisplayValue // 应用于表单输入组件 getByAltText getByTitle getByTestId debug screen.debug(); screen.debug(screen.getByText('test)); screen.debug(screen.getAllByText('test)); or console.log(prettyDOM()) logRoles(); import {getRoles} from '@testing-library/dom' const nav = document.createElement('nav') nav.innerHTML = ` Item 1 Item 2 ` console.log(getRoles(nav)) // Object { // navigation: [], // list: [], // listitem: [, ] // } 复杂项目使用步骤 官网给的示例都比较简单，在实际项目中使用还是有些问题的，如： 组件包含异步api请求 可将其请求全部代理到本地已存在的api mock server上 组件依赖父组件传入的props 如onchange事件，如何在测试中直接触发其onchange具体实现而不是简单mock 可直接渲染其父组件，从而不用考虑待测组件（子组件）props的问题，前提是父组件并无或者只有简单的props参数要求 如直接会渲染其下的所有组件，这样就和用户实际访问的ui一样了，但这样会把不相干的组件都渲染 可以直接渲染待测组件，然后手动使用store.dispatch等去触发前置需要的一些数据 推荐方法1 redux初始/更新的state如何同步到测试中去 使用包含store的自定义render去render组件 以下是本人大量调试测试后给出的方案： 使用自定义render 去render相关测试组件 ```js export const setupStore = (extendStore = {}) => { const nlsReducer = (state = {}) => { return state; }; const initState = { [PROJECT_PRESET.STORE_KEY]: { global: globalState, application: applicationState, amendment: amendmentState, }, [PROJECT_PRESET.NLS_KEY]: initIntl(), ...extendStore, }; const reducers = combineReducers({ [PROJECT_PRESET.STORE_KEY]: rootReducer, [PROJECT_PRESET.NLS_KEY]: nlsReducer }); return createStore(reducers, initState, applyMiddleware(thunk)); }; /** Render with all providers @param {*} ui render node @param {preloadedState, path} options preloadedState will preload rootReducer path will change location path @returns */ export const renderWithProviders = (ui, options = { preloadedState: {}, path: '' }) => { const { preloadedState, path } = options; const store = setupStore(preloadedState); const history = createMemoryHistory(); if (path) { history.push(path); } const wrapperProviders = ({ children }) => { return ( {children} ); }; // 导出store是为了在某些测试场景中可以直接使用store.dispatch(xx)去触发相关action从而达到更新reducer值的目的 // 参考https://redux.js.org/usage/writing-tests#preparing-initial-test-state // 导出并展开原始render是因为原始render返回的结果里是一个对象，包含container, baseElement等对象，应一一返回 return { store, // store could dispatch action later to change reducer state data ...render(ui, { wrapper: wrapperProviders, }) }; }; ``` render 顶层或参数简单的组件 组件中有异步请求的使用findByxxx才能正确拿到所需元素 it('component should display correct value', async () => { renderWithProviders(); const dom = await screen.findByText('testIssue'); expect(dom).toBeInTheDocument(); }); Q: RTL 不关注实现细节，那组件中的实现相关的覆盖率如何保证？ A: Any complex logic shouldn’t be living in the components, and that’s why the React Testing Library doesn’t focus on testing at that level. Business logic should be decoupled from the component. By doing so, you can unit-test it using only Jest. 这段话很好解释了测试的原则，组件中不应包含复杂的逻辑，任何的业务逻辑应该从组件中解耦出来，然后进行单独的单元测试，这时候只用jest就可以了 快照测试 本意是好的（提醒开发者注意组件的变化），但执行时因为代码的更改会频繁的导致快照失败，开发者只是简单的更新快照使其pass而已，在code review的时候也很难去发现变化，所以并不建议使用 Jest Snapshot 快照测试不仅能用于ui组件的dom，它能用来测试一切js对象，所以可以应用到API的快照测试上。 it('will check the matchers and pass', () => { const user = { createdAt: new Date(), id: Math.floor(Math.random() * 20), name: 'LeBron James', }; expect(user).toMatchSnapshot({ createdAt: expect.any(Date), id: expect.any(Number), }); }); // Snapshot exports[`will check the matchers and pass 1`] = ` Object { \"createdAt\": Any, \"id\": Any, \"name\": \"LeBron James\", } `; API 快照demo import * as API from 'api'; test('failed login (bad password)', async () => { let data; try { data = await API.login('me@example.com', 'wrong_password'); fail(); } catch(e) { expect(e.response.data.error).toMatchSnapshot(); } }); 易错 测试Error时，该对象是特殊的对象，比如error= new Error（‘ttt’）,如果直接输出console.log(error)，并不会打印出error对象而是打印出error.toString()的相关信息 E2E Test 阅读UI-testing-best-practices Puppeteer vs Cypress 简单总结： Puppeteer是浏览器自动化处理工具并不是专门的UI测试工具，所以很多特点功能如: skip/only 超时设置 截图 当前测试case状态 调试 序列运行 等都需要额外的设置或其他工具辅助，不如cypress来的高效直接和简单。 cypress优势总结 如果只是用来抓取数据或其他自动化浏览器操作的 cypress并不是最好的选择，它只是用于UI测试 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/jade.html":{"url":"technology/frontend/jade.html","title":"jade","keywords":"","body":"Jade 一定要注意每行的对其和缩进，由此会生成对应的节点，不然有可能出错 如果不指定具体的html标签，默认是div #name 输出 div#foo.bar.baz 转换为 p 文本,大段的文本用.换行追加 p. sdsd sdsd sdssd 特殊字符转义 p \\#{something} 它会输出 #{something} 单行注释//xxxxx,多行注释，把要注释的段缩进在//之内就行 条件语句最好加上括号，避免出错 继承，前置，追加 这三个功能都需要从别的文件引入，比较容易搞混，区别如下 继承，前置关键字 block/extends，包含是 include 包含只是包含了一个文件内的文本而已，可以是任何东西，继承和前置必须是jade模板 实例 继承 ```html //common.jade block head //inherit.jade extends ./common.jade html block head 最终渲染如下 ```html //子类实现,覆写了 前置 ```html //conmon.jade block head //inherit.jade extends ./common.jade html append head 最终渲染如下 ```html //父类的追加 //自己的实现,不会覆写父类 包含 ```html //common.jade i am from common //inherit.jade html include common.jade 最终渲染 ```html i am from common mixin,调用时前面要用+号 mixin pets(pets) ul.pets - each pet in pets li= pet //调用 -var petsx=['dog','cat'] +pets(petsx) //这样调用，官网出错 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/jest.html":{"url":"technology/frontend/jest.html","title":"jest","keywords":"","body":"Jest vscode 没有api 提示，需要安装 @types/jest; jest 23 后需要安装jest-watch-typeahead 才能使用过滤文件功能 断言基本没变化 only,skip和mocha相比有变化，作用域不再跨文件，只在该测试文件内有效。 mock 函数，使用jest.fn()创建 mock属性 mockImplementation/mockImplementationOnce mockReturnValue/mockReturnValueOnce jest常用 spyOn() const video = { play() { return true; }, }; test('plays video', () => { const spy = jest.spyOn(video, 'play');//不同于expect的createSpy() const isPlaying = video.play(); expect(spy).toHaveBeenCalled(); expect(isPlaying).toBe(true); spy.mockReset(); spy.mockRestore(); }); snapshot 测试 即首次运行保存某个组件的渲染快照，之后每次渲染都和快照进行比对，如果不匹配就失败，如果组件后面有修改，需要更新快照文件，jest --updateSnapshot update snapshoot 也可以使用 w 显示更多里面的 u选项 mock modoule 参考这个库 参考2,mock部分 // mock es6 的class写法，必须返回一个function 即constructor, 然后内部返回的就是class的实例方法 // jest.requireActual(xxx)/jest.requireMock(xxx) jest.mock('./sound-player', () => { return function() { return {playSoundFile: () => {}}; }; ); //或者这样，这种可以测试sound-player类是否被调用 jest.mock('./sound-player',()=>{ return jest.fn().mockImplementation(()=> { playSoundFile: () => {} }) }) mock document event手动触发 const evt = document.createEvent(\"HTMLEvents\"); evt.initEvent(\"scroll\", false, true); document.dispatchEvent(evt); ==== const event = new CustomEvent('message'); event.xxx = {xxx}//任何自定义对象 window.dispatch(event)/document.dispatchEvent(event); 5.mock 系统变量 delete window.location window.location = {xxx} //或者 Objeact.defineProperty(window,'location',{xxxx}); 6.mock 组件 import A from '../a'; import B from '../b'; // 这样就能直接mount(A),而不用去关心B的内部实现了 jest.mock('./b',()=>{ return jest.fn().mockImplementation(()=>({ render:()=>(test node) }))) }) Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/frontend/cypress.html":{"url":"technology/frontend/cypress.html","title":"cypress","keywords":"","body":"Cypress Core concept 配置 cypress.json Cypress Studio 功能（操作录制） cypress.json中 设置experimentalStudio: true打开该功能，某些时候很好用 Cypress selector 可视化的通过鼠标显示dom选择代码 support file setup文件 test suit/case 覆写配置 description('',{browser: '!chrome'},()=>{ it('', {baseUrl: 'localhost:3022'},()=>{ }) }) 语法 Jquery 同步选择xx.then cy // cy.get() looks for '#element-does-not-exist', repeating the query until... // ...it doesn't find the element before its timeout. // Cypress halts and fails the test. .get('#element-does-not-exist') // ...this code is never run...直接访问并交互 .then(($myElement) => { doSomething($myElement) }) cy.xx不返回对象，只是yield到下一个进行链式操作，它是异步的 Alias 共享上下文dom/变量 用法一： this.xx beforeEach(() => { // alias the users fixtures cy.fixture('users.json').as('users') }) it('utilize users in some way', function () { // access the users property const user = this.users[0] // make sure the header contains the first // user's name cy.get('header').should('contain', user.name) }) 需要注意的是: this 是同步的，必须得等as执行完后才能使用，一般是把as放在hook里 错误示范 it('is not using aliases correctly', function () { cy.fixture('users.json').as('users') // nope this won't work // // this.users is not defined // because the 'as' command has only // been enqueued - it has not run yet const user = this.users[0] }) //正确可以如下使用 cy.fixture('users.json').then((users) => { // now we can avoid the alias altogether // and use a callback function const user = users[0] // passes cy.get('header').should('contain', user.name) }) 使用this时，测试用例不能使用箭头函数，指向不对 用法二：cy.get('@xxx') // 共享变量 beforeEach(() => { // alias the users fixtures cy.fixture('users.json').as('users') }) it('utilize users in some way', function () { // use the special '@' syntax to access aliases // which avoids the use of 'this' cy.get('@users').then((users) => { // access the users argument const user = users[0] // make sure the header contains the first // user's name cy.get('header').should('contain', user.name) }) }) // 共享dom it('disables on click', () => { cy.get('button[type=submit]').as('submitBtn') cy.get('@submitBtn').click().should('be.disabled') //不用then }) 动态生成case describe('if your app uses jQuery', () => { ;['mouseover', 'mouseout', 'mouseenter', 'mouseleave'].forEach((event) => { it('triggers event: ' + event, () => { // if your app uses jQuery, then we can trigger a jQuery // event that causes the event callback to fire cy.get('#with-jquery') .invoke('trigger', event) .get('#messages') .should('contain', 'the event ' + event + 'was fired') }) }) }) 断言 cy.xx.should() 适合cy开头的集成测试（链式调用断言） expect('xx').to.be.xx，适合单元测试（计算结果断言） click click({force: true}),强制点击不检查是否可见/被覆盖/可用等 click({position: 'leftTop'}) 点击不同位置 cy.intercept 类似jest中的mock，可以用来mock请求 ```javascript // 常见用法 cy.intercept('/activities/', { fixture: 'activities' }).as('getActivities') // mock baseUrl+/activities/下的请求（注意baseUrl,有些包含#和api路径并不一样），返回值为fixture/activities.json // visit the dashboard, 会触发activities请求，即先mock然后再触发 // the two routes above cy.visit('http://localhost:8888/dashboard') // 等待返回 cy.wait('@getActivities').then((response)=>{ //处理response }) - cy.fixture 静态数据，一般在fixtures/xxx.json或者xxx.jpg,可以是任何静态数据 - cy.stub()/cy.spy() stub可以理解为 ```javascript cy.stub(obj, 'method') // force obj.method() to return \"foo\" cy.stub(obj, 'method').returns('foo') // 会改变方法行为，类似jest.mock cy.spy(obj, 'method');//不会改变方法行为，只是为了判断是否被调用 调试 方法一 debugger it('let me debug when the after the command executes', () => { cy.visit('/my/page/path') === cy.get('.selector-in-question').click(); debugger();// 错误方式，因为cy.xx()是异步的，所以得不到selector-in-question元素，应该在then中debugger,注意 // 此时要先把click等命令去掉，如下 === cy.get('.selector-in-question').then(($selectedElement) => { // Debugger is hit after the cy.visit // and cy.get command have completed debugger //这样在cypress上重新运行测试用例会在停止浏览器中的对应代码块位置，可以调试上下文， // 推荐这种方式 }) }) 方法二.debug(); it('let me debug like a fiend', () => { cy.visit('/my/page/path') cy.get('.selector-in-question').debug();//也是会在浏览器中对应的地方停住，但和方法一不同，只会把selector-in-question输出在console 面板中，而不是source 面板中查看不了上下文变量 })； 方法三cy.pause(); it('let me debug like a fiend', () => { cy.visit('/my/page/path') cy.pause();//会暂停在这块，也是在浏览器console中查看 cy.get('.selector-in-question').click(); })； Code Coverage Visual Testing 常见问题 只有最后一条command会被retry 参考 cy.get('.new-todo').type('todo B{enter}') cy.get('.todo-list li') // queries immediately, finds 1 , 生成dom有延时的情况，一般来说不会出现这样的问题 .find('label') // retried, retried, retried with 1 只会等待这条重复执行 .should('contain', 'todo B') // never succeeds with only 1st 解决方案： 1. 合并命令 cy.get('.new-todo').type('todo B{enter}') cy.get('.todo-list li label') // 1 query command .should('contain', 'todo B') // assertion 2. 立即断言 cy.get('.new-todo').type('todo A{enter}') cy.get('.todo-list li') // command .should('have.length', 1) // assertion .find('label') // command .should('contain', 'todo A') // assertion cy.as（）hook中使用问题 所有的alias在执行每一条test case时候的会被重置，所以要放在beforeEach中而不是before中 cy.hover() cypress种没有这个方法，会引起一些问题，解决方案 cy.get('.nav').trigger('mouseover') 终极实践 Cypress in all 流程测试 组件测试+visual testing 单元测试 以上汇总成Code Coverage Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/":{"url":"technology/tools/","title":"工具经验","keywords":"","body":"工具和软件 用到的工具和软件相关经验技巧总结。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/chrome.html":{"url":"technology/tools/chrome.html","title":"chrome技巧和调试经验","keywords":"","body":"Chrome Tricks NetworkCondition Request Blocking Living Debug Mobile Capture Copy Debug Variable NetworkCondition quick start shift+cmd+p NetworkCondition This tools have many agent that can simulate different browsers to debug. Request Blocking quick start shift+cmd+p Blocking Using scenario some request that can't visit in local, e.g xx.google.com, and it will block network request , so we can use this tool to block that requests speed network request. Living Debug solution 1 pen sources tab , select a js to debug, change code directly and ctrl+swill save code temporary, this is a awesome feature for debugging solution 2 using overrides, (chrome->sources tab->overrides) see this Notice overrides is different with Filesystem(workspace), workspace like IDE ,it make you can change/save original file in chrome, overrides just save temporary. Importand, override must apply on real file(js/css/img etc.), which mean those fetch from network panel.In most of cases, we run webpack app, if we debug from browser source panel, on a source map file e.g. test.js, that will not work , because browser will not load that file, it will load real bundled file or chunk file(see from network panel) . so follow below step to fix it: find wanted debug file in source panel locate real file from network panel edit real file in source panel right click save as overrides Mobile Capture quick start shift+cmd+p capture This will capture screen or full size screen Copy Debug Variable using scenario When your debug is blocking, you can see a variable value, if value is an object , it's not easy to copy or console whole properties, using copy command ,you can easy did it. debug and block execute copy(variable) in console panel, then you can paste all properties everywhere. Console API console.count(obj)/console.countReset(obj) console.group(obj)/console.groupEnd(obj) console.time(obj)/console.timeEnd(obj) console.table(obj) Performance see this just notice the main timeline which has red function block, it means that function has performance issue Audit see this Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/docker.html":{"url":"technology/tools/docker.html","title":"docker笔记","keywords":"","body":"Docker 参考 入门到实战 概念 拉取镜像,镜像名都是镜像:标签这样的格式 数据卷 就是把本地的文件夹或者文件映射到容器中,从而进行独立于容器的持久化,一般是使用一个数据卷容器来作为其他容器的共享数据的地方 常用步骤 创建一个数据卷容器docker run -tdi -v /local/data:/data --name data_s ubuntu:14.04,注意需要在docker中先设置可以被共享的本地的目录,都是绝对路径 创建其他容器,调用数据卷容器docker run -ti --volumes-from data_s --name web1 ubuntu:14.04,web1当中就有了这个共享的数据卷,路径目录和数据卷容器一样,（一般都用绝对路径) demo: 创建一个基于nginx（目录结构）的数据卷容器 docker run -itd --name nginx_data -v /Users/garywang/test_data/nginx_html:/usr/share/nginx/html nginx:latest (注意必基础镜像的目录必须存在，比如/usr/share/nginx/html 就是nginx首页的目录地址) 在本地的 /Users/garywang/test_data/nginx_html 目录中新建index.html,自定义内容 创建新的nginx容器，vloume 来自nginx_data docker run -itd --name nginx_from_volume -p 2035:80 --volumes-from nginx_data nginx:latest 浏览器中访问localhost:2035 就会显示自定义的首页内容。 网络 端口映射 有-P/-p之分,不一样,前者映射本地随机一个端口号到内部容器的开放端口号上,后者指定本地端口号和容器端口号（甚至ip）格式 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort docker run -d -P training/webapp python app.py 随机映射 docker run -d -p 5000:5000 training/webapp python app.py 查看端口映射配置 docker port ContainerName 5000,输出127.0.0.1:49155 命令 运行docker run -it --name con01 busybox:latest,和拉取的格式不同 参数 -i 表示这是一个交互容器,会把当前标准输入重定向到容器的标准输入中,而不是终止程序运行,-t 指为这个容器分配一个终端。 -d 表示守护态运行,即后台运行,使用docker attach ContainerName 进入守护态的容器,按 Ctrl+D 可以退出这个容器了。 每次执行 docker run 命令都会创建新的容器,建议一次创建后,使用 docker start/stop 来启动和停用容器。 删除docker rm $(docker ps -a -q) 查看容器, docker ps -a, 如果不加-a 只能列出当前运行的容器, -a 可以列出所有的容器包括已经停止的 进入容器 在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令（退出时容器不会结束还会守护态后台运行） 创建 Dockerfile 创建镜像 创建名称为‘Dockerfile’的文件,一定要是这个 当前目录执行命令docker build -t=\"ouruser/sinatra:v2\" ., 注意后面的'.', 表示当前路径下 Commit 创建镜像 运行一个容器,在容器中进行必要的修改,退出 运行命令docker commit -m \"Added json gem\" -a \"Docker Newbee\" 0b2616b0e5a8 ouruser/sinatra:v2, -a 表示作者信息,后面的ID表示以哪个容器为准（容器ID）,后面是标签 push 上传镜像 dockerhub 完成注册,运行命令docker push xxx:v1 导出/导入 镜像 导出 docker save -o ubuntu_14.04.tar ubuntu:14.04 导入 docker load -i ubuntu_14.04.tar,导入时不用指定名称和标签,会自动写入保存时的 导出/导入 容器 导出 docker export 7691a814370e > ubuntu.tar 导入 docker import ubuntu.tar xxx:version 需要注意的是导入的结果不是在容器中而是作为新的镜像导入,另外和镜 像导入不同的是需要手动指定名称和标签 logs docker logs containerName 打印对应容器的日志 Dockerfile CMD 类似ENTRYPOINT,容器启动时会执行，只执行一次， RUN, 镜像初始化安装时执行的语句 WOOKDIR,为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录 ONBUILD,配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/sketch.html":{"url":"technology/tools/sketch.html","title":"sketch笔记","keywords":"","body":"Sketch 快捷键 快速选中内部(图层下的图层)图层 cmd + click 绘制图形时移动图形 space 由中心改变图形大小 按住 option 再拉动大小 和缩放不一样，缩放会一起改变样式比如border的大小，这个不会 重复上一步操作 cmd + D Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/vscode.html":{"url":"technology/tools/vscode.html","title":"vscode技巧总结","keywords":"","body":"Vscode vscode 相关使用技巧 快捷键 ： cmd+k,cmd+t;格式化选中代码 cmd+alt+up/down;向上多选光标 cmd+up/...;到文件头，尾... shift+cmd+o;在文件中符号之间导航 ctrl+g;跳转到指定行 alt+click;多选光标 shift+alt按住；自由拖动多行选择 cmd+d;选中同名的单词，并产生光标 操作 信息预览；在某个类或者方法上右键“查看定义”，可快速预览 git diff; 在gitt中选中文件右键，查看diff或者，右键选中一个文件右键“对比“，之后再选择另一个文件即可 markdown,在编辑的文件中cmd+k v,(v不用同时按cmd),就可以分屏预览了 snippets,代码片段 cmd+shift+p ,输入snippets选择一种语言，设置对应的代码片段，只有在这种语言下才有效snippet 语法 \"For Loop\": { \"prefix\": \"forx\", \"body\": [ \"for (var ${1:index} = 0; ${1:index} 主要是body里面的，分三种 1.Tabstops，$0,$1..这种的用来表示游标次序和位置，$1第一，$0是最后 2.Placeholders，${1:foo}，1是游标顺序，foo是带填充的名 称 3.$name,使用系统变量，如$TM_FILENAME,是获取当前文件名称，其余查官方文档 插件使用技巧 Jest Runner user setting 中设置jest.pathToConfig 值为项目中jest.config文件的地址 项目必须在一个单独的workspace下，或者是workspace下的主项目 打开某个spec文件，编辑 integrated terminal 右上角选择jest， output panel查看输出 debug, 使用vscode内置debug,不用该插件在it...上显示的debug link, 配置launch.json文件如下 如果有提示说找不到静态的json文件，是因为需要运行npm run test:server，这样就会把json文件全部server //调试当前文件， 一般用这个 { \"type\": \"node\", \"request\": \"launch\", \"name\": \"vscode-jest-tests\", \"program\": \"${workspaceFolder}/node_modules/.bin/jest\", \"args\": [\"${relativeFile}\",\"--config=jest.config.json\"], \"console\": \"internalConsole\", \"internalConsoleOptions\": \"neverOpen\", \"disableOptimisticBPs\": true, \"windows\": { \"program\": \"${workspaceFolder}/node_modules/jest/bin/jest\", } }, // 调试全部测试 { \"name\": \"vscode-jest-tests\",// jest 插件规定必须命名成这个，这样点击debug link才能正确launch. \"type\": \"node\", \"request\": \"launch\", \"env\": { \"NODE_ENV\": \"test\" }, \"cwd\": \"${workspaceRoot}\", \"program\": \"${workspaceRoot}/node_modules/.bin/jest\", \"stopOnEntry\": false, \"args\": [ \"--runInBand\", \"--config=jest.config.json\" // jest 配置文件路径 ], \"runtimeArgs\": [\"--nolazy\"], \"console\": \"internalConsole\", \"sourceMaps\": false, \"internalConsoleOptions\": \"openOnSessionStart\" } Debugger For Chrome 和浏览器下直接调试一样，好处就是不用开浏览器的调试，可以再vscode里直接调试 项目必须被server(npm run start), 然后配置launch configuration 断点启动调试 { \"name\": \"Debug for chrome(dev)\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:8080/burnaby08/ui.do?method=booking&target_tab_id=tab1\", \"sourceMaps\": true, \"webRoot\": \"${workspaceFolder}\", \"userDataDir\": \"${workspaceFolder}/.vscode/chrome\"// 存贮调试产生的文件 } Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/zeplin.html":{"url":"technology/tools/zeplin.html","title":"zeplin技巧总结","keywords":"","body":"Zeplin import assets from PS choose all layers , right click from artboard window -> extension -> zeplin choose all assets within previous artboard -> mark as assets export to zeplin, see below: Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/jenkins.html":{"url":"technology/tools/jenkins.html","title":"jenkins笔记","keywords":"","body":"Jenkins Install brew install jenkins Start cmd jenkins --httpPort=8076,then getting start. Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/magica_voxel.html":{"url":"technology/tools/magica_voxel.html","title":"magica_voxel笔记","keywords":"","body":"MagicaVoxel 使用提示 Brush -> setting - HDPI 关闭，提升性能 特殊形状如楼梯 圆环等可以在笔刷中的shader中通过设置参数进行绘画 y 鼠标画完一个图形时，按住cmd键，会显示该对象的轴，可以拉伸调整，最重要的如果是用shader画的，可以保持聚焦，然后动态调整参数实时看到效果 x 红 y 黄 z 蓝 世界地图中可以对大场景中的对象使用layer （分层）管理，选中一个对象，然后点击想放入层数字前的箭头,不是数字本身，点击数字小圆点隐藏该图层 shader 使用时实时显示参数调整后效果操作： 1. 左侧brush选择shader, attach 2.右侧选择shader,3. 使用鼠标直接画，而不是点击执行按钮 建议使用大小256x256x256, 这样模型更顺滑有细节，默认40出来的完全不是一个效果 快捷键 按下shift 删除笔画 x+click 新建焦点 选中选区后 ctrl+click 配合转动视图可以随意移动选区 ctrl+d 取消选区 shift + 选择 多选，shift+alt+选择 减选 G 移动物体到地面 shift+物体移动箭头 是复制该对象，和ctrl c/v不同，这个是针对整个对象整体 选中多个物体按U融合成一个，和分组不一样(window 不生效) 复制时，多用repeat功能 而不是ctrl c/v shear 切边，快速切出阶梯，屋顶等 色板左边可以加备注 色板中 选中某个颜色 cmd+alt+拖动（ctrl+alt windows），设置选中颜色的渐变， 两端选择两个颜色会在两种颜色之间渐变 色板中选中多个颜色，右键rand 随机填充颜色，和rand命令一样 Render 材质选发光的时候，可以在摄像机选项中开启bloom,选择面数，大小等调整光线 command rand 1 10 随机填充色板1到10号颜色，从左下角开始数，1开始计数 常用来做随机效果，完后再删去某一种或几种颜色的色块，形成凹凸不平的效果 pal mask 在色板标注出未使用的颜色 maze 如maze 8 生成边长长度为8的迷宫 疑问 立体画笔必须基于某个点才能画，所以不能直接在空间中画一个东西出来，可以现在地面画个柱子，再基于柱子去定位去画，最后删除柱子即可 氛围渲染 太阳、光照强度（阴天，晴天），光照角度 天空，颜色 雾气 shader画完后物体选择消失，没法调节参数 插件和软件 Jsplacement https://windmillart.net/?p=jsplacement 8k地图生产器 Shaders List https://github.com/stars/clownvary/lists/voxel ArtChanny https://drive.google.com/drive/folders/10sfl7Og5uspGtCWsp1S2_fDdPbKGkuDW Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/tools/mac_proxy.html":{"url":"technology/tools/mac_proxy.html","title":"mac代理","keywords":"","body":"Mac 代理 浏览器代理 使用 switchomega 桌面应用代理(含终端) clashx中添加要访问的url代理规则，或者直接选择全局代理 终端中 输入 export https_proxy=http://127.0.0.1:7890; export http_proxy=http://127.0.0.1:7890; export all_proxy=socks5://127.0.0.1:7890 此代理只在当前终端生效，关闭后重置 桌面应用中可以在具体的应用设置里找看是否有代理的设置 Tip Q: 如何确定当时是否已正确切换代理了？ A: 终端中输入 curl ipc.cc 可查看当前自己的ip是否已是代理（ipc.cc也要先添加进代理规则） Q: 已经正确显示代理地址，但还是ping不通google.com？ A: clashx代理是基于tcp或者udp协议，而ping是走的icmp协议因此在clash下不能ping通google Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/":{"url":"technology/others/","title":"其他","keywords":"","body":"其他 其他相关技术的经验技巧总结。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/babel.html":{"url":"technology/others/babel.html","title":"最熟悉的“陌生人”---babel","keywords":"","body":"Babel分享 全面了解babel 最熟悉的“陌生人”---babel.pptx Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/mask_danmaku.html":{"url":"technology/others/mask_danmaku.html","title":"蒙版弹幕","keywords":"","body":"蒙版弹幕 个人蒙版弹幕的技术原理分享 在线演示 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/http_https_proxy.html":{"url":"technology/others/http_https_proxy.html","title":"Http/Https代理转发相关知识","keywords":"","body":"Http/Https 代理转发相关知识 背景需求 公司现有一站点siteA，上面有很多API调用 电脑多有网络请求必须经过公司代理服务器 proxyCom,否则直接拒绝 需要把siteA上面的API请求过滤出来，自动存贮对应的json数据到指定目录，从而方便后面本地mock api 实现思路 创建一个本地的node server, e.g. localhost:5050 浏览器使用switchyMega 插件设置代理为localhost:5050 浏览器上所有的请求理论上应该全部被该server 拦截，从而截取response，做自定义处理 Http proxy 这一部分其实很好代理，因为http本身是明文传输，所以设置好代理后，会直接捕捉到所有的请求，直接修改即可，这里使用node-http-proxy 这个包，方便实现。 代码实现 http->http const http = require('http'); const httpProxy = require('http-proxy'); const proxy = httpProxy.createProxyServer(); proxy.on('error', function (err, req, res) { res.writeHead(500, { 'Content-Type': 'text/plain' }); res.end('Something went wrong. And we are reporting a custom error message.'); }); proxy.on('proxyReq', function(proxyReq, req, res, options) { proxyReq.setHeader('X-Special-Proxy-Header', 'foobar'); console.log('RAW request from the target'); }); proxy.on('proxyRes', function (proxyRes, req, res) { var body = new Buffer(''); proxyRes.on('data', function (data) { body = Buffer.concat([body, data]); }); proxyRes.on('end', function () { body = body.toString(); console.log(\"res from proxied server:\", body); res.end(\"my response to cli\");// 所有的原始请求response都会被该结果重写 }); }); http.createServer(function (req, res) { // 直接转发到原始网站 proxy.web(req, res, { target: 'http://' + req.headers.host, target: 'https://proxyCom.com', selfHandleResponse: true // false时直接原样转发 }); // 实际使用时，因为我们所有的请求要走公司的代理服务器proxyCom,同时还有验证用户，所以设置如下 // proxy.web(req, res, { // target: 'https://proxyCom.com', // auth:'username:password',// 如果不想明文配置，可以如下以base64编码配置在headers中 // headers: { // Authorization: 'the calculation result here' // 浏览器console中使用btoa('username:password') // }, // selfHandleResponse: true // false时直接原样转发 // }); }).listen(9000); https->http // 这里创建一个https 的代理服务器，所以要配置对应的证书，并不是说拦截所有的从浏览器 // 来的请求需要配置ssl,（https必须使用mitm攻击才可以）如果我们不加listen相当于没有创建这个代理的server // 这个https的代理会把所有的 http 请求加密然后转发到localhost 9009上 httpProxy.createServer({ target: { host: 'localhost', port: 9009 }, ssl: { key: fs.readFileSync('valid-ssl-key.pem', 'utf8'), cert: fs.readFileSync('valid-ssl-cert.pem', 'utf8') } }).listen(8009); https->https // 这个是创建一个https的代理服务器同时转发所有的http请求到对应的https target // 所有secure意思是代理服务器转发请求时要不要验证target的证书，这个因为是在node中 // 转发，所以可配置，其实和浏览器设置不检查安全证书是一样的，所以就能理解为什么secure // 只能在这种case中使用了。 httpProxy.createServer({ ssl: { key: fs.readFileSync('valid-ssl-key.pem', 'utf8'), cert: fs.readFileSync('valid-ssl-cert.pem', 'utf8') }, target: 'https://localhost:9010', secure: true // Depends on your needs, could be false. }).listen(8000); Https proxy Https 相比http 虽然只多了一个字母，但两者实现的复杂度上，https是要远远超过http的，主要是相关的概念比较多，一定要清楚，所以在实现https代理前，我们先了解下相关的概念。 https 访问过程： 核心过程主要在4, 这里客户端浏览器要去验证服务端发来的证书的合法性，一般是某个权威的CA证书机构颁发的证书，其实证书就是秘钥，所以结论如下： CA证书: 核心的颁证机构，也叫根证书，一般是各大机构和操作系统厂商合作预置在用户系统或者浏览器当中 server 证书: 是在权威CA机构申请的、对应某个域名服务器的证书 所以访问时是浏览器去验证服务端发来的证书是不是从其系统内根证书（CA）所申请来的，千万别把两种证书搞混了。 明白了以上概念，我们大致的实现思路也就有了，如下： 创建一个自己的CA根证书，并添加到系统的信任组当中 通过该CA 创建我们要拦截的的对应的站点证书（自动创建），这样在自己这台电脑上，就能通过浏览器的安全验证 创建一个https的server, 动态导入上一步的证书和私钥，这样就能让本地的请求以为我们的server就是它要访问的真实server,达到欺骗的效果 我们的server 转发原始的请求到真实的server上同时拦截返回的请求，做完处理后，再返回给原始的请求 以上过程，类似于在客户端和服务器端加了一个透明的中间人，两头并不会感知到中间人的存在，所以该过程也称为man in the middle, 即 mitm, 是一种非常危险的攻击方式。 代码实现 这里我们使用http-mitm-proxy这个库来实现 var Proxy = require('http-mitm-proxy'); var proxy = Proxy(); proxy.onError(function(ctx, err) { console.error('proxy error:', err); }); proxy.onRequest(function(ctx, callback) { // ctx(context),当前这个请求的上下文 if (ctx.clientToProxyRequest.headers.host == 'www.baidu.com' && ctx.clientToProxyRequest.url.indexOf('/s') == 0) { ctx.use(Proxy.gunzip); ctx.onResponseData(function(ctx, chunk, callback) { chunk = new Buffer(chunk.toString().replace(/百度/g, '鸡你太美!'));//这样会把百度搜索结果中的所以‘百度’字符替换成目标字符，可以自定义我们的其他处理 return callback(null, chunk); }); } return callback(); }); proxy.listen({ port: 9000 }, e => { console.log('proxy listening') }); 需要注意的有三点： 可能需要关闭代理发https请求到目标站点的安全检查，ctx.proxyToServerRequestOptions.rejectUnauthorized = false;参考 在运行以上代码后生成的.http-mitm-proxy文件夹中我们需要找到ca.pem然后导入到系统的根证书列表中，导入方法可自行查询 查阅文档可发现，proxy实例和ctx几乎拥有一模一样的生命周期方法，一开始不理解，后来发现其实就是两者控制范围的不同，前者的范围是所有的请求，后者只是当前请求，所以一般针对某个请求的过滤或者特殊处理，可以放在ctx的生命周期中，全局的一些处理放在proxy中 一般情况，以上实现我们就能拦截到对应的请求，但由于我们的请求必须经过公司的proxyCom,所以还得需要捕获到的请求先转发到proxyCom，由于http-mitm-proxy并没有提供代理的代理 这样的功能，这里经过查阅资料找到以下解决方案，node-https-proxy-agent 最终实现如下 var Proxy = require('http-mitm-proxy'); var HttpsProxyAgent = require('https-proxy-agent'); var proxy = Proxy(); var agent = new HttpsProxyAgent({ host:'https://proxyCom.com', port:80, headers: { Authorization: 'the calculation result here' // 浏览器console中使用btoa('username:password') } }); proxy.onError(function(ctx, err) { console.error('proxy error:', err); }); proxy.onRequest(function(ctx, callback) { ctx.proxyToServerRequestOptions.rejectUnauthorized = false; // 关闭代理发https请求到目标站点的安全检查 if (ctx.clientToProxyRequest.headers.host == 'www.baidu.com' && ctx.clientToProxyRequest.url.indexOf('/s') == 0) { ctx.use(Proxy.gunzip); ctx.onResponseData(function(ctx, chunk, callback) { chunk = new Buffer(chunk.toString().replace(/百度/g, '鸡你太美!')); return callback(null, chunk); }); } return callback(); }); proxy.listen({ port: 9000, httpAgent: agent, // 添加agent httpsAgent: agent }, e => { console.log('proxy listening') }); Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/python.html":{"url":"technology/others/python.html","title":"python笔记","keywords":"","body":"Python笔记 字符 Ascii 最早的只有英文和数字的编码 Unicode，统一所有语言的编码，但比较大不便于传输 utf-8，方便传输和更小的编码 一般工作流程是 字符拼接，类似c语言 print（‘this is my grade %s’ % grade）` 需要注意的是%转义%%,同是也可以使用连接字符+,或者使用多个逗号分隔输出 语法 字符前加'r',表示需要原始字符 name = r\"Newlines are indicated by \\n\", 回车会原样输出 布尔值，and or not, '==','! =' 空值，None list、tuple、dict、set list=['jack','tom','mary'] list.insert(2,'david') list.pop(2) tuple，不可变数列，是只指向内容不可变，并不是说内容的内容也不可变 >>> t = ('a', 'b', ['A', 'B'])//注意和list的不同就在于***使用括号包裹*** >>> t[2][0] = 'X' >>> t[2][1] = 'Y' >>> t ('a', 'b', ['X', 'Y'])//变得是内部的list,tuple的指向位置并没有变，除非内部的内容也是tuple的 tuple只有一个元素时 t=(1,)//加一个逗号来消除歧义 dict 字典 d = {'Michael': 95, 'Bob': 75, 'Tracy': 85} get：d.get('Bob')/d['Bob'],没有d.Bob这种方式 set：d['new']='new' delete: d.pop('Bob') clear: d.clear() set 不可重复的序列，和dict相比没有value,y=set('google')//y 为['e', 'o', 'g', 'l'] 可以交、并操作 >>> s1 = set([1, 2, 3]) >>> s2 = set([2, 3, 4]) >>> s1 & s2 {2, 3} >>> s1 | s2 {1, 2, 3, 4} collestions 模块 namedtuple,可以自定义tuple名称和属性 from collestions import namedtuple Point = namedtuple('Point',['x','y']) p =Point(1,2) p.x p.y defaultdict,设置没有某个键值时默认值，使 会抛出keyerror错 Counter 计数器 >>> c = Counter(\"abcdefgab\") >>> c[\"a\"] 2 >>> c[\"c\"] 1 >>> c[\"h\"] 0 条件判断，if-else-elif,注意不是elseif 循环 for ..in x while break 跳出循环 continue 结束本轮循环，开始下一轮 pass 占位符，啥都不做 string *,重复输出字符串，‘hello*2’=>hellohello [:],截取字符串，‘hello[1:2]’,截取1到2的字符 逆向截取 'hello'[-1] >>> o reverse 'hello'[::-1] >>> olleh in/not in,是否存在字符串 h in \"hello\",返回布尔值 ‘’‘ 三引号，用来连接复杂字符html = ''' Friends CGI Demo ERROR %s ''' 元组参考这个 不允许删除，但可以删除整个元组，del tup 字典 dict.items()/keys()/values(),返回对应的值和键，可以遍历 dict.pop([key]),删除某个item datetime/time,一般使用datetime模块即可 日期获取和转换 import time; curtime = time.localtime(time.time()); print(time.strftime(\"%Y-%m-%d %H:%M:%S\",curtime)); 使用datetime,注意datetime下面还有一个datetime的类，如果没有指定导出则应该再访问一层from datetime import timedelta datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")； datetime.now() + timedelta(hours=10)//加10小时 datetime.now() + timedelta(days=-1)//减去1天 函数 参数 def printX(str,str2): print(str+str2); printX('1','2');//必备参数 printX(str2='1',str1='2');//关键字参数，顺序可以不一样 def printX(str,str2,age=32)://缺省参数，如果不传则使用默认的 def printX(str,str2,*last)://不定长参数，last表示后面所有的参数 def printX(str,str2,**lastKey)://不定长参数，last表示后面所有的关键字参数，形如printX(1,2,name='test',age='20'),lastKey 即为{name:'test',age:20} 匿名函数（lambda）,只能编写简单函数 lambda [arg1 [,arg2,.....argn]]:expression # 可写函数说明 sum = lambda arg1, arg2: arg1 + arg2;//类似箭头函数 sum(1,2); 列表生成式 [x * x for x in range(1, 11)],快速生成一个列表 全局变量/局部变量 函数体外面定义的就是全局变量，但要注意的是内部使用全局变量的时候要加global 关键字声明，不然不能使用 globvar = 0 def set_globvar_to_one(): global globvar # 使用 global 声明全局变量 globvar = 1 模块导入 import datetime/from datetime import time(只导入time部分) as xxx，注意语法问题from在前 包 需要有一个init.py的文件表示是一个包，这个文件夹下可以有不同的py文件，import的时候就可以指定部分导入 可以使用as别名 可以直接导入包，但默认还是要导出具体的包内模块名，否则使用不了，不像java导入后可以直接package.xx.xxx, 但可以有个变通的方法就是把具体的导入模块名写在对应的init.py文件中,如下 print \"__init__\" from pet import name as pet_name, run as pet_run #from animal.pet import name as pet_name, run as pet_run #from .pet import name as pet_name, run as pet_run dir（xx）,返回一个模块里定义的所有模块，变量和函数 如果要导入的自定义模块和程序文件不在一个目录，需要追加sys.path，这样才能找到看这个 moduleA __init__.py Person.py moduleB main.py # 此时main.py要导入Person需要如下设置 # main.py import os, sys sys.path.append(os.path.abspath('')) import moduleA.Person 返回多个值 def get_args(): return (1,3) a,b = get_args() IO input，接收用户输入,可以接收一个表达式 str = input(\"请输入：\"); print \"你输入的内容是: \", str 读写文件都用with 语句 with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') stringIO,BytesIO和文件IO不同的是，这个两者都是从内容中读写内容，而不是从文件中 异常 捕获语句,不是catch,try: xxx; except (IOError,ValueError)://只捕获这两种异常类型; except :// 不带异常类型则捕获所有的异常 except ValueType as arg:// 带参数的异常，arg是*这个*异常类型的对应实例参数 xxx except Exception as arg:// 带参数的异常，arg是*所有*异常类型的对应实例参数 xxx finally: xxx 触发异常，raise，相当于throw assert 断言处理异常 try: assert 1==2,'this is error';//如果为假就抛出错误 except AssertionError as e: print(e); if __name__=='__main__'，意思是如果直接执行改模块则name是main,如果是被导入到别的模块再执行，name就是模块名 docstring,函数，类，模块都应该包含docstring,说明做了什么返回什么，都用三引号，方便换行 命名规范，变量 方法都是小写，没有驼峰，可以使用下划线类 类首字母大写，常量大写 内置全局方法 setattr()/getattr()/delattr()/hasattr bin()/oct()/hex(),10进制数转换成2进制/8进制/16进制 id(）返回对象内存地址 hash() dir()返回模块内部的所有方法、变量、属性 var()返回模块内部的所有属性 any/all,前者是判断可迭代对象中有任意一个不为空或者false则返回true,后者是所有的都不为空或false,才返回true filter/map/reduce,和一般的差不多，唯一不同是调用方式，第一个参数是操作函数，第二个才是可迭代对象 format,格式化字符 site = {\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"} print(\"网站名：{name}, 地址 {url}\".format(**site)) sum([0,1,2]) //对迭代对象求和 unichr()/chr(),返回编码对应的unicode字符/字符号（不是编码） ord()//返回字符的asiic码或者unicode码 zip()//拉链函数，组合成一个可遍历对象 >>>a = [1,2,3] >>> b = [4,5,6] >>> list(zip(a,b))//python3中要加list函数才能显示 >>> [(1, 4), (2, 5), (3, 6)] 函数式编程 高阶函数，把函数当成变量传入 返回函数，函数当成结果返回，返回函数中不要引用任何可能会变化的变量 def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum; lazy_sum(1,2,3)();//这样调用 装饰器，类似redux中的中间件参考 import functools; def logtext(text): def log(func): @functools.wraps(func)//加上这个相当于执行了wrapper.__name__ = func.__name__，不然pnow的__name__指向会是wrapper[参考](https://www.zhihu.com/question/46808546/answer/102887411) def wrapper(*param): print(text,func.__name__); func(*param); return wrapper; return log; @logtext('this is test')// 相当于执行了pnow=logtext('this is test')(pnow);,@xxx,是python语法 //此时的pnow就指向了新的包装过的函数，如果直接调用pnow()相当于调用logtext('this is test')(pnow)(),就会执行内部程序， //也可以手动logtext('this is test')(pnow)()，结果是一样的 def pnow(): print('2015-6-7'); pnow(); //修饰带参数的函数 def works_for_all(func): def inner(*args, **kwargs): print(\"I can decorate any function\") return func(*args, **kwargs) return inner @works_for_all def divide(a,b): ... 偏函数，就是把某个函数的某个参数给固定住，返回一个新的函数，这样调用起来比较方便 int('123',base=8); //使用偏函数 import functools; int8=functools.partial(int,base=8); int8('123');//直接调用这样 面向对象编程 实例化没有new关键字，子类同名方法会覆写父类 类方法都有self参数，一般调用也不用传入，类似js中的this,代表实例。 继承class C(A, B): # 继承类 A 和 B,注意初始化时得手动调用父类的初始化方法，调用父类方法得加上self参数 class person: def __init__(self,age): self.__age=age;//使用私有变量更加健壮 def getAge(self): return self.__age; class men(person): def __init__(self,sex): person.__init__(self,11);//手动调用父类初始化方法 self.sex=sex; def getSex(self): print(person.getAge(self));//调用父类方法得加上self参数 return self.sex; @classmethod //类方法,第一个参数是类本身，调用时直接person.getClassName() def getClassName(cls): @staticmethod //静态方法，调用时直接person.getClassName() def getClassName(): .... private变量__xxx,表示只能在类内部使用self.xxx访问，protected变量_xxx,只允许内部和子类访问,__init__,类似这样的是特殊方法,这只是从语法层面进行的一种约定限制，如果知道约定直接访问也可以访问得到 判断类型 import types, types.FunctionType....,判断函数等复杂类型 基本类型，if 123==int... ==,is 前者比较内容，后者比较Id(内存地址) isinstance(d, Dog) hasattr(methodA,'call')判断是否是函数类型 if(type(1)==type(3)) if(isinstance(1,int)) slots类属性，定义之后可以在实例上动态的添加定义过的属性 class person: __slots__=('name','age');# 用tuple定义允许绑定的属性名称 a=person(); a.name='gary'; a.age=20; a.score=21;//出错，因为没定义过 @property,属性装饰器,注意访问形式，是x.birth//x.birth=120;不是以方法的形式 class Student(object): @property//代表可读，它会创造一个对应的birth.setter def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property//只读，不可写 def age(self): return 2015 - self._birth 枚举类， from enum import Enum,unique; @unique class Week(Enum): Mon=0 Thu=1; Whe=2; Thr=3; Fri=4; print(Week.Mon.name); print(Week.Mon.value); 进程 os.fork(),和一般函数不同，它调用一次返回两次，分别在父进程和子进程分别返回 该方法只能用在unix系统下 子进程返回0，父进程返回子进程的pid,子进程只需要调用getppid()就可以拿到父进程的ID。multiprocessing 包可以跨平台 跨平台 from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid())) if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 分布式进程，看demo文件 正则表达式 以r开头，消除歧义 s = r'ABC-001' # Python的字符串 hashlib,常用的hash和sha1等hash算法 import hashlib md5 = hashlib.md5() md5.update('how to use md5 in python hashlib?'.encode('utf-8')) print(md5.hexdigest()) 异步IO async/await import asyncio async def hello(): print(\"Hello world!\") r = await asyncio.sleep(1) print(\"Hello again!\") CMD(shell) 执行shell脚本使用 Subprocess 模块,参考 call check_call check_output Time 参考 print('timestamp',time.time()) tuple_time = time.localtime(time.time()) print('time tuple',tuple_time) print('time.strftime',time.strftime('%Y%m%d-%H%M%S',tuple_time)) sys.args, 获取参数 import sys, getopt arg = sys.argv; opts, args = getopt.getopt(arg[1:],'hi:o:',['version=']) //'i: 代表后面是有值的' for op,value in opts: if op == \"-i\": print('-i',value) elif op == \"-o\": print('-o',value) elif op == \"-h\": print('-h',value) elif op in '--version': print('version',value) >> python3 xx.py -h -i a.file --version=1.2 列表推倒 listone = [2, 3, 4] listtwo = [2*i for i in listone if i > 2] #满足大于2条件时，执行前边的语句 print(listtwo) 常用库 getopt获取命令行参数 subprocess子进程command 多版本管理-pyenv-virtualenv或者终极方案pipenv chardet字符编码检测 使用注意 pyenv python的版本管理器 pipenv python中用的包的版本管理器，两个不一样, pyenv+viatualenv插件相当于既有了python的环境管理，也有了第三方包的管理 当使用pyenv进入虚拟环境比如3.8.8时，就在可以不用输入python3 xxx,执行命令，直接输入python就是当前的解释器版本 pipenv 使用流程 （不推荐使用了） cd project pipenv --python 3.x | pipenv --python 2.xx 这样就创建了一个虚拟的开发环境，如果不使用此命令默认创建基于当前的python版本的环境 pipenv shell 激活虚拟环境的shell,不激活的话还是相当于在系统默认的环境下去操作，安装的包在全局， pipenv install xxx --dev 这样这个模块就被安装在了虚拟环境中，和全局的就没有冲突，程序执行时也会从虚拟环境下去寻找 python index.py (或者不进入shell,在外层执行 pipenv run python index.py)执行具体的脚本或命令 exit 退出虚拟环境 可以做一个实验，在虚拟环境下装的包在pipenv shell之后可以正常导入，但一旦退出运行就会报错 pyenv + viratualenv插件 (不推荐使用了) 概念阐述 在开发Python应用程序的时候，系统安装的Python只有一个版本：如3.4。所有第三方的包都会被pip安装到Python的site-packages目录下。 如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。pyenv(配合virtualenv 插件）就是用来为一个应用创建一套“隔离”的Python运行环境。 使用 安装pyenv 和virtualenv 插件 参考win 确定版本 # 1. 查看正在使用的python版本 $ pyenv version system (set by /usr/local/var/pyenv/version) # 2. 查看系统支持的python版本 $ pyenv versions # 3. 查看系统支持的python版本 （如果系统目前的版本里没有你想要的，可以参考列表安装) $ pyenv install -l # 4. 安装指定版本的pyton $ pyenv install 3.6.0 # 5. pyenv local 设置当前目录使用的python版本 $ mkdir py3 && cd py3 && pyenv local 3.6.0 # 验证： # MacBookPro in /tmp/py3 $ python -V Python 3.6.0 # MacBookPro in /tmp/py3 $ cd $ python -V Python 2.7.10 # 6. 全局切换python版本 $ pyenv global 3.6.0 （pyenv versions 可查看能使用的版本） 创建虚拟环境 # 1. 创建虚拟环境 $ pyenv virtualenv 3.6.0 py360 (基于3.6.0 别名叫py360) # 2. 进入环境 $ pyenv activate py360 之后就可以在这里安装各种依赖和包，完全独立的 # 验证： $ python -V Python 3.6.0 (py360) # 3. 退出环境 $ pyenv deactivate py360 # 4. 查看系统python环境 $ pyenv versions * system (set by /usr/local/var/pyenv/version) 3.6.0 3.6.0/envs/py360 py360 别名显示在第二行 # 5. 删除环境 $ pyenv virtualenv-delete py360 anaconda 推荐使用 注意安装包时因为使用国内的镜像，需要关闭vpn代理，否则会有奇怪错误抛出 包管理器/ python环境管理器 /跨平台非python语言包管理器/gui图形界面 几点概念： 环境：一个环境就是一个python 版本对应的整个环境，如python 3.8可以有一个环境，3.9可以有一个 包管理： 不同环境的包相互独立，如3.8环境的conda install之后都是在这个环境里 安装.whl文件 切换到对应环境后 pip install --no-deps D:\\download\\torch-1.11.0+cu115-cp38-cp38-win_amd64.whl 基本使用： 创建环境：conda create -n py38 python=3.8 查看环境：conda info -e 激活环境：conda activate py38 推出环境：conda deactivate py38 代码美化 fomatter black 其他 练习demo Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/rxjs.html":{"url":"technology/others/rxjs.html","title":"rxjs笔记","keywords":"","body":"Rxjs笔记 参考这个 Observable 简单理解就是数据发射器（如何产生数据) 可以被\bunsubscribe Observer 简单理解就是\b数据监听器（如何处理数据） 本质上是有next/error/complete方法的一个对象 Subject 即是Observable （可以被subscribe） 又是Observer (本身有next方法，可以直接多播数据) 操作符 静态操作符（用来产生observable的） Rx.Observable.interval(1000); 实例操作符（用来对observable进行操作的） const observable=Rx.Observable.interval(1000); observable.map(xxx); 多播、单播 subject 共享Observable execution 普通的Observable 每个都是独立的Observable execution 看这个 注意 subscribe(next,[err],[complete]) 后两个参数是可选的，即错误回调和完成回调，有一些是没有完成回调的，比如interval是无穷的，其实subscribe里面的就是一个observer(观察者)对象，是这个对象订阅了外面的Observable，不是Obseervable订阅了自己 及时销毁订阅，unsubscribe,一般使用ng2内置的async通道来自动取消 |async 用于promise/observable Rx.Notification.createOnnext subject 和observable的区别是subject可以多路广播共享一个作用域，后者是独立的作用域看这个 这样理解 subject既可以被观察，也能当做observer处理事件，当它作为observer时相当于一个proxy，就是说本来一个普通的Observable （称为A)以subject(称为B)作为observer后，这个A上的subscribe（即B）被触发时，B上的subscribe也会被触发，所以就相当于B是个桥梁使A间接的触发了多路广播 既是观察者（可以订阅被观察者）又是被观察者（可以重新触发/发送新的值） 其实Subscribe（next,err,comple） 就是subscbe({ next:funcA(x), err:xx, completed:xx })的简写 由于subject同时也是observe所以就相当于也具有next，err等属性，所以会有subject.next(4)（注意参数就是funcA(4)) 这种方法，其实就是调用的observer中的next回调,然后广播，并不是别的什么next方法 operator 大全 参考这个 合并类 操作符 pluck,提取目的源的某个属性，参数可以是一个或多个,如下 var clicks = Rx.Observable. fromEvent(document, 'click'); var tagNames = clicks.pluck 'target','tagName');// 提取event. arget.tagName var target = clicks.pluck('target'); / 提取event.target tagNames.subscribe(x => console.log x)); zip联想记忆 拉链 和combineLatest不同在于zip 要求源1的第一个数据和源2的第一个数据组成一对，产生结果流的第一个数据；源1的第二个数据和源2的第二个数据组成一对，产生结果流的第二个数据。而 combineLatest 不需要等待另一个源数据流产生数据，只要有一个产生，结果流就会产生。 重要的区别点在于 zip 严格的需要多个源数据流中的每一个的相同顺序的元素配对。 combineLatest 合并两个数据流的最后一次数据 创建类操作符 from from 可以支持从数组、类似数组的对象、Promise、iterable 对象或类似Observable的对象（其实这个主要指ES2015中的Observable）来创建一个Observable var array = [10, 20, 30]; var result$ = Rx.Observable.from (array); result$.subscribe(x => console.log (x)); fromEvent 一般用来操作DOM事件 var click$ = Rx.Observable.fromEvent(document, 'click'); click$.subscribe(x => console.log(x)); fromEventPattern function addClickHandler(handler) { document.addEventListener('click', handler); } function removeClickHandler(handler) { document.removeEventListener('click', handler); } var click$ = Rx.Observable.fromEventPattern( addClickHandler, removeClickHandler ); click$.subscribe(x => console.log(x)); Interval let source = Rx.Observable .interval(500 /* ms */) .take(3); let subscription = source.subscribe( function (x) { console.log('Next: ' + x); }, function (err) { console.log('Error: ' + err); }, function () { console.log('Completed'); }); Timer Rx.Obserable.timer(2000) 延迟2000毫秒后返回一个值为0的observable Rx.Obserable.timer(2000,100)延迟2000毫秒后每隔100毫秒返回一个值为自增的observable，类似interval 过滤类操作符 filter Filter操作只允许数据流中满足其predicate测试的元素发射出去，这个predicate函数接受3个参数： 原始数据流元素 索引,这个是指该元素在源数据流中的位置（从0开始） 源Observable对象 // 提取0-5中的偶数 let source = Rx.Observable.range(0, 5) .filter(function (x, idx, obs) { return x % 2 === 0; }); debounceTime 抖动时间，类似delay debounce是空闲时间必须大于或等于 一定值的时候，才会执行调用方法。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/package-lock.html":{"url":"technology/others/package-lock.html","title":"package-lock相关概念","keywords":"","body":"NPM package-lock issues From npm v5.x if you run npm install will generate a package-lock.json file case1: have lock file package.json package-lock.json run npm install see this case2: no lock file package.json package-lock.json run npm install, package-lock will be generated then same with case1. case3: update we update a lib in package.json manually, then run npm install, it may rewrite lock file except update lib correspondingly. solution if we do not need package-lock feature, we need add file .npmrc and add line package-lock = false case3 soluton a. run npm install libA@x.x.x manually will only update libA in lock file. b. do not use prefix in package.json ,like ^1.2.1 or ~1.2.1, then you can run npm install. if you need install dependency by lock file , you need to run npm ci not npm install. Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/computer_config.html":{"url":"technology/others/computer_config.html","title":"个人mac配置笔记","keywords":"","body":"Mac Settings mac相关配置 终端用户名太长 执行下面命令“Tmp”是你想要改的电脑名称 sudo scutil --set HostName Tmp [参考这个](http://blog.csdn.net/z3512498/article/details/51245853) 相关工具 tree,目录树生成，brew install tree即可 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/spider.html":{"url":"technology/others/spider.html","title":"python爬虫笔记","keywords":"","body":"Python 爬虫笔记 如何入门 Python 爬虫 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"technology/others/code_review.html":{"url":"technology/others/code_review.html","title":"code review笔记","keywords":"","body":"Code review How to code review nitpick, 并非强制需要改动，但需要注意 解决冲突必要时面对面交流，文字评论容易误解对方情绪。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"hobby/":{"url":"hobby/","title":"兴趣爱好","keywords":"","body":"兴趣爱好 个人兴趣爱好相关经验总结。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"hobby/know_the_movie.html":{"url":"hobby/know_the_movie.html","title":"电影概念和技术","keywords":"","body":"认识电影 概念 特写 用来引起注意，引导观众 声音靠视觉引导，演员如何寻找观众就如何感觉 景别 远 人物不能超过还画框1/2 交代时空背景，环境和地点[故事发生在哪] 全 1/2 以上 建立戏剧场景[人物在哪] 中 膝盖或腰部以上 展开人物动作[人在干什么] 近 胸部以上 呈现人物表情[人在想什么] 特 肩膀以上 强调场景细节[提醒观众注意什么] 总结： 由远及近，环境逐渐淡出，人物逐渐突出 人眼日常习惯全景 中景，建议多用远景和特写，显得不单调，区别日常视角，多利用角度、道具 拍摄角度 俯拍 正三角 崇高，高大 仰拍 倒三角，不稳固 渺小，弱小 主观镜头 第一人称视角，调动情绪 空镜头 中断场景，切换场景 结合上下情境抒发情感 镜头/人物运动 水平运动 从左到右 符合生活直觉 从右到左 显得更有力量感 垂直运动 向上，象征积极，进发 向下，象征衰落，消极 纵深运动 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"hobby/shoot.html":{"url":"hobby/shoot.html","title":"摄影","keywords":"","body":"摄影/像基础概念 延时摄像、延时拍照、慢放、快进的区别 正常一秒24帧 慢放是增加每秒的帧率，比如每秒120帧，就可以把视频时长拉长5倍（120/24=5）达到视觉上慢放的效果 延时摄像（缩时摄影）是刚好和慢放相反，降低每秒的帧率，比如每秒2帧，拍摄2x60秒=120张，然后缩短播放时间到正常的24帧每秒，120/24=5 ，就是得到5秒的延时效果 延时拍照，和延时摄像类似，一个是静态一帧一帧拍，一个是动态自动取帧拍，延时拍照更加灵活一些，比如可以给每张照片设置不同的曝光时间或者参数，提高每张照片的质量，最后在导入软件序列制成视频。 拍摄间隔计算方法，1. 先确定自己需要多久的延时效果，比如10秒，需要10x24=240张照片。2. 确定自己需要拍摄多久，比如5分种。那就是5x60=300秒，所以间隔就是300/24=1.25秒。在拍一些运动变化较快的场景时，间隔要小，比如车流、人流，在一些变化慢的间隔要大，比如云彩、星空等。 快进，从视觉效果上来说和延时是相同的，但不同点有二： a. 快进是正常的帧率拍摄，然后压缩时长，在需要拍延时跨度很大的场景时，视频的体积会很大。 b. 延时摄像或拍照，可以单独设定帧率，并且每帧设定拍摄参数，成像质量是快进不能比的。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"hobby/外汇.html":{"url":"hobby/外汇.html","title":"外汇","keywords":"","body":"外汇 概念 参考地址：http://www.xingyetouzi.com/chinese/hylp/forex/page2.html 理解: 因为是美元账户，切都已美元做基准，所以一下交易都已美元为基础货币 以EUR/USD 1.2002为例 买多：因为我的账户里是美元，所以相当于我看好欧元要大量买入欧元，抛售美元，此时的止损就是下跌到1.2001就平仓，止盈到1.2005就平仓（抛出欧元，换回美元），最后我手里的还是美元，但因为欧元汇率涨了3点，所以就赚了3点。 买空：一开始不理解，是这样，因为手里只有美元没有欧元，但我不看好欧元，要抛货怎么办呢，先以美元作为抵押，从银行手里拿到一定数量的欧元，然后卖出，这时止损1.2005（这时买入欧元，还给银行，再不买汇率更长，更吃亏）,止盈1.2001（这时买入欧元，还给银行）赚一个点 价格： 同一个汇率会有两个报价，因为都是平台商在报价，我们本质上是在和平台交易，所以他们会有两个报价一个卖价一个买价，注意这里的买、卖是相对于客户来说的，意思就是我买澳元、卖澳元的汇率，平台商报价都是低买高卖（注意这里的是相对于平台商来说），所以给我们的报价就是卖价格低，买价格高，差的点就相当于佣金。 还有注意的是，如果你买多 和买空同一个货币，那么货币当前的汇率是不同的，买多的显示的是平台商报价的最新卖价，买空的显示的是平台商报价的最新买价，感觉好黑！ 交易类型 1.直接定价，间接定价 前者是一般是1个单位或100个单位的外币能够折合多少本国货币 大部分国家采用这种方法，如USDJPY 112.195 表示美元兑日元 后者一般是1个单位或100个单位的本币能够折合多少外国货币 部分国家采用这种方法，如GBPUSD,1.05978 表示英镑兑美元 2.基本面分析 基本面的分类： 1、经济形势； 2、政治因素； 3、军事动态； 4、政府、央行政策； 5、市场心理； 6、投机交易； 7、突发事件。 3.技术面分析 a.历史会重复 b.价格活动是有趋向性的 c.市场行为将所有事物打了折扣. 图表 1.蜡烛线 2.趋势走势线，斜率 3.移动平均线，高于平均价买入，低于卖出 4.平仓 和强行平仓不同 前者指卖出一部分，在某个价格又买回同样的数量 后者指被第三方直接抛出 头寸，就是可动用的款项的意思，可以这么理解 止损单，限价单 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"hobby/bitcoin.html":{"url":"hobby/bitcoin.html","title":"比特币","keywords":"","body":"Bitcoin 钱包 可用的有电脑，移动（bread wallet,beithe），web(block chain)类型的. 钱包的作用就是管理私钥，公钥，接受/发送比特币。 私钥，这是最重要的，一个私钥可以对应多个公钥地址。 私钥可以由钱包自己生成，也可以自己自定义通过这个生成,生成的私钥可以导入之前的钱包，这样相关的资金就会存入这个私钥账户中来。 公钥，这是用来接受比特币的，必须记住，每次接受时都要用自己的私钥重新生成一个新的公钥来接受，原则就是一个公钥只使用一次，这样能保证安全和隐私。 钱包一般生成的账户有两种， 一种是普通账户，私钥对外公开一个公钥，用来接受比特币。 一种是HD(hierarchical deterministic)账户,该私钥每次接受比特币可以生成一个新的公钥地址来保护隐私。 个人管理方案 根据使用金额大小分为以下场景 小额：手机移动收付 大额：离线/冷钱包进行收付 洗钱，转移，跨国，跑路：使用blockchain 手机端使用HD账户+普通私钥账户配合日常使用，注意HD的备份导入和普通的不同，普通的就是一串私钥字符串，HD的是单词组/二维码。 普通私钥账户用于接受捐赠等长期固定的收付。 HD账户用于高频次的，短期交易。 离线/冷钱包使用HD或普通私钥，当手机端账户余额多时，通过冷钱包的公钥地址将比特币转入冷钱包。冷钱包私钥做好备份。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 其他相关经验技巧总结。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "},"other/天朝生存秘籍.html":{"url":"other/天朝生存秘籍.html","title":"天朝生存秘籍","keywords":"","body":"天朝生存秘籍 报案报警. 遇到困难或者有了麻烦，比如丢了自行车，丢了苹果机，在民警看来可能不是什么大事，但对我们老百姓来说却不是小事，面对国内民警踢皮球以及敷衍的办事态度，怎样才能让他们把我们的事当成事办呢？ 解决方案：找一个老外，让老外代报警，相信我对于我们这样一个神奇国度，任何事情只要一涉及外交，重要性立马成指数增长，而且遇见老外的案子，国内民警办事效率那不是一般高啊！ 记住，在我国民间流传着这样一句话“一等洋人，二等官，三等少民，四等汉”。 逆向思维 孩子吃奶粉，国内媒体通通报道国内媒体无公害，同时以超严格的标准针对进口品牌，所以进口的品牌必定无时无刻会有无数双眼睛盯着，这样严苛的监管下必定出问题的概率是很小的，所以可以参考购买这样的奶粉。同理可延至生活中购买商品的方方面面，比如食品，数码产品，汽车等等。 Copyright © garyw 2020 all right reserved，powered by Gitbook修订时间： 2024-03-28 02:16:16 "}}